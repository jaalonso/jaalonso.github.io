<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es">
<head>
<!-- 28 de febrero del 2025 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tema 9: Declaraciones de tipos y clases</title>
<meta name="author" content="José A. Alonso" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../../../css/estilo-org.css" />
<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
</head>
<body>
<div id="preamble" class="status">
<p><a href="/"><i class="fa fa-home"></i></a> |
   <a href="/curso-i1m/i1m/">Inicial</a> |
   <a href="/curso-i1m/i1m/temas_apuntes_codigos.html">Temas  </a> |
   <a href="/curso-i1m/i1m/manuales.html">Manuales  </a> |
   <a href="/curso-i1m/i1m/ejercicios.html">Ejercicios  </a> |
   <a href="/curso-i1m/i1m/examenes.html">Exámenes  </a> |
   <a href="/curso-i1m/i1m/doc.html">Documentación  </a>
</p>
</div>
<div id="content" class="content">
<h1 class="title">Tema 9: Declaraciones de tipos y clases</h1>
<div id="table-of-contents" role="doc-toc">
<h2>&Iacute;ndice</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgc932253">1. Declaraciones de tipos</a>
<ul>
<li><a href="#orgaa833fc">1.1. Declaraciones de tipos como sinónimos</a></li>
<li><a href="#org7287420">1.2. Declaraciones de tipos nuevos</a></li>
<li><a href="#org90fd81c">1.3. Declaraciones de tipos parametrizadas</a></li>
<li><a href="#orgc73e219">1.4. Declaraciones anidadas de tipos</a></li>
</ul>
</li>
<li><a href="#orga2a82e1">2. Definiciones de tipos de datos</a>
<ul>
<li><a href="#org593754f">2.1. Definición de tipos con data</a></li>
<li><a href="#org43618ce">2.2. Uso de los valores de los tipos definidos</a></li>
<li><a href="#org552c768">2.3. Definición de tipo con constructores con parámetros</a></li>
<li><a href="#orgb366772">2.4. Definición de tipos con parámetros</a></li>
</ul>
</li>
<li><a href="#orgc54b6b8">3. Definición de tipos recursivos</a>
<ul>
<li><a href="#orgc658d32">3.1. Definición de tipos recursivos: Los naturales</a></li>
<li><a href="#orgf77dd65">3.2. Definiciones con tipos recursivos</a></li>
<li><a href="#org7663962">3.3. Tipo recursivo con parámetro: Las listas</a></li>
<li><a href="#orgb3f636d">3.4. Definición de tipos recursivos: Los árboles binarios</a></li>
<li><a href="#org302de78">3.5. Definiciones sobre árboles binarios</a></li>
<li><a href="#org600791c">3.6. Definiciones sobre árboles binarios</a></li>
<li><a href="#orge316c2e">3.7. Definiciones de distintos tipos de árboles</a></li>
</ul>
</li>
<li><a href="#org43e9373">4. Sistema de decisión de tautologías</a>
<ul>
<li><a href="#org15bbeed">4.1. Sintaxis de la lógica proposicional</a></li>
<li><a href="#orgd1c2f0e">4.2. Semántica de la lógica proposicional</a></li>
</ul>
</li>
<li><a href="#orgb74b377">5. Máquina abstracta de cálculo aritmético</a>
<ul>
<li><a href="#org546cc3c">5.1. Evaluación de expresiones aritméticas</a></li>
<li><a href="#orge561778">5.2. Máquina de cálculo aritmético</a></li>
</ul>
</li>
<li><a href="#org0b210d5">6. Declaraciones de clases y de instancias</a>
<ul>
<li><a href="#org18bc419">6.1. Declaraciones de clases</a></li>
<li><a href="#org6ee0d83">6.2. Declaraciones de instancias</a></li>
<li><a href="#org264bb63">6.3. Extensiones de clases</a></li>
<li><a href="#orgaa1474b">6.4. Instancias de clases extendidas</a></li>
<li><a href="#orgeb6ab81">6.5. Clases derivadas</a></li>
</ul>
</li>
<li><a href="#orgc0515eb">7. Material complementario</a></li>
<li><a href="#org68148e0">8. Bibliografía</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgc932253" class="outline-2">
<h2 id="orgc932253"><span class="section-number-2">1.</span> Declaraciones de tipos</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgaa833fc" class="outline-3">
<h3 id="orgaa833fc"><span class="section-number-3">1.1.</span> Declaraciones de tipos como sinónimos</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Se puede definir un nuevo nombre para un tipo existente mediante una
<b>declaración de tipo</b>.</li>

<li><p>
Ejemplo: Las cadenas son listas de caracteres.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">String</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Char</span><span style="color: #707183;">]</span>
</pre>
</div></li>

<li>El nombre del tipo tiene que empezar por mayúscula.</li>
</ul>
</div>
</div>

<div id="outline-container-org7287420" class="outline-3">
<h3 id="org7287420"><span class="section-number-3">1.2.</span> Declaraciones de tipos nuevos</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>Las declaraciones de tipos pueden usarse para facilitar la lectura de
tipos.</li>

<li><p>
Las posiciones son pares de enteros.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">Pos</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Int</span>,<span style="color: #228b22;">Int</span><span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
<code>origen</code> es la posición (0,0).
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">origen</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Pos</span>
<span style="color: #0000ff;">origen</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">(</span>0,0<span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
<code>(izquierda p)</code> es la posición a la izquierda de la posición <code>p</code>. Por
ejemplo,
</p>
<pre class="example">
izquierda (3,5)  ==  (2,5)
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">izquierda</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Pos</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Pos</span>
<span style="color: #0000ff;">izquierda</span> <span style="color: #707183;">(</span>x,y<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">(</span>x<span style="color: #a0522d;">-</span>1,y<span style="color: #707183;">)</span>
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org90fd81c" class="outline-3">
<h3 id="org90fd81c"><span class="section-number-3">1.3.</span> Declaraciones de tipos parametrizadas</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li><p>
Las declaraciones de tipos pueden tener parámetros. Por ejemplo,
<code>Par a</code> es el tipo de pares de elementos de tipo <code>a</code>
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">Par</span> a <span style="color: #a0522d;">=</span> <span style="color: #707183;">(</span>a,a<span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
<code>(multiplica p)</code> es el producto del par de enteros <code>p</code>. Por ejemplo,
</p>
<pre class="example">
multiplica (2,5)  ==  10
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">multiplica</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Par</span> <span style="color: #228b22;">Int</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Int</span>
<span style="color: #0000ff;">multiplica</span> <span style="color: #707183;">(</span>x,y<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> x<span style="color: #a0522d;">*</span>y
</pre>
</div></li>

<li><p>
<code>(copia x)</code> es el par formado con dos copias de <code>x</code>. Por ejemplo,
</p>
<pre class="example">
copia 5  ==  (5,5)
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">copia</span> <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Par</span> a
<span style="color: #0000ff;">copia</span> x <span style="color: #a0522d;">=</span> <span style="color: #707183;">(</span>x,x<span style="color: #707183;">)</span>
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-orgc73e219" class="outline-3">
<h3 id="orgc73e219"><span class="section-number-3">1.4.</span> Declaraciones anidadas de tipos</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>Las declaraciones de tipos pueden anidarse. Por ejemplo,
<ul class="org-ul">
<li><p>
Las posiciones son pares de enteros.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">Pos</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Int</span>,<span style="color: #228b22;">Int</span><span style="color: #707183;">)</span>
</pre>
</div></li>
<li><p>
Los movimientos son funciones que va de una posición a otra.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">Movimiento</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Pos</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Pos</span>
</pre>
</div></li>
</ul></li>

<li><p>
Las declaraciones de tipo no pueden ser recursivas. Por ejemplo, el siguiente
código es erróneo.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">Arbol</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Int</span>,<span style="color: #7388d6;">[</span><span style="color: #228b22;">Arbol</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
Al intentar cargarlo da el mensaje de error
</p>
<pre class="example">
Cycle in type synonym declarations
</pre></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orga2a82e1" class="outline-2">
<h2 id="orga2a82e1"><span class="section-number-2">2.</span> Definiciones de tipos de datos</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org593754f" class="outline-3">
<h3 id="org593754f"><span class="section-number-3">2.1.</span> Definición de tipos con data</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>En Haskell pueden definirse nuevos tipos mediante <code>data</code>.</li>

<li><p>
El tipo de los booleanos está formado por dos valores para representar lo
falso y lo verdadero.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">Bool</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">False</span> <span style="color: #a0522d;">|</span> <span style="color: #228b22;">True</span>
</pre>
</div></li>

<li>El símbolo <code>|</code> se lee como "o".</li>

<li>Los valores <code>False</code> y <code>True</code> se llaman los <b>constructores</b> del tipo <code>Bool</code>.</li>

<li>Los nombres de los constructores tienen que empezar por mayúscula.</li>
</ul>
</div>
</div>

<div id="outline-container-org43618ce" class="outline-3">
<h3 id="org43618ce"><span class="section-number-3">2.2.</span> Uso de los valores de los tipos definidos</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>Los valores de los tipos definidos pueden usarse como los de los
predefinidos.</li>

<li><p>
Definición del tipo de movimientos:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">Mov</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Izquierda</span> <span style="color: #a0522d;">|</span> <span style="color: #228b22;">Derecha</span> <span style="color: #a0522d;">|</span> <span style="color: #228b22;">Arriba</span> <span style="color: #a0522d;">|</span> <span style="color: #228b22;">Abajo</span>
</pre>
</div></li>

<li><p>
Uso como argumento: <code>(movimiento m p)</code> es la posición obtenida
aplicando el movimiento <code>m</code> a la posición <code>p</code>. Por ejemplo,
</p>
<pre class="example">
movimiento Arriba (2,5)  == (2,6)
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">movimiento</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Mov</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Pos</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Pos</span>
<span style="color: #0000ff;">movimiento</span> <span style="color: #228b22;">Izquierda</span> <span style="color: #707183;">(</span>x,y<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">(</span>x<span style="color: #a0522d;">-</span>1,y<span style="color: #707183;">)</span>
<span style="color: #0000ff;">movimiento</span> <span style="color: #228b22;">Derecha</span>   <span style="color: #707183;">(</span>x,y<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">(</span>x<span style="color: #a0522d;">+</span>1,y<span style="color: #707183;">)</span>
<span style="color: #0000ff;">movimiento</span> <span style="color: #228b22;">Arriba</span>    <span style="color: #707183;">(</span>x,y<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">(</span>x,y<span style="color: #a0522d;">+</span>1<span style="color: #707183;">)</span>
<span style="color: #0000ff;">movimiento</span> <span style="color: #228b22;">Abajo</span>     <span style="color: #707183;">(</span>x,y<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">(</span>x,y<span style="color: #a0522d;">-</span>1<span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
Uso en listas: <code>(movimientos ms p)</code> es la posición obtenida aplicando la
lista de movimientos <code>ms</code> a la posición <code>p</code>. Por ejemplo,
</p>
<pre class="example">
movimientos [Arriba, Izquierda] (2,5)  ==  (1,6)
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">movimientos</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Mov</span><span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Pos</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Pos</span>
<span style="color: #0000ff;">movimientos</span> <span style="color: #707183;">[]</span>     p <span style="color: #a0522d;">=</span> p
<span style="color: #0000ff;">movimientos</span> <span style="color: #707183;">(</span>m<span style="color: #228b22;">:</span>ms<span style="color: #707183;">)</span> p <span style="color: #a0522d;">=</span> movimientos ms <span style="color: #707183;">(</span>movimiento m p<span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
Uso como valor: <code>(opuesto m)</code> es el movimiento opuesto de <code>m</code>.
</p>
<pre class="example">
movimiento (opuesto Arriba) (2,5)  == (2,4)
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">opuesto</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Mov</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Mov</span>
<span style="color: #0000ff;">opuesto</span> <span style="color: #228b22;">Izquierda</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Derecha</span>
<span style="color: #0000ff;">opuesto</span> <span style="color: #228b22;">Derecha</span>   <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Izquierda</span>
<span style="color: #0000ff;">opuesto</span> <span style="color: #228b22;">Arriba</span>    <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Abajo</span>
<span style="color: #0000ff;">opuesto</span> <span style="color: #228b22;">Abajo</span>     <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Arriba</span>
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org552c768" class="outline-3">
<h3 id="org552c768"><span class="section-number-3">2.3.</span> Definición de tipo con constructores con parámetros</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>Los constructores en las definiciones de tipos pueden tener parámetros.</li>

<li><p>
Ejemplo de definición
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">Figura</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Circulo</span> <span style="color: #228b22;">Float</span> <span style="color: #a0522d;">|</span> <span style="color: #228b22;">Rect</span> <span style="color: #228b22;">Float</span> <span style="color: #228b22;">Float</span>
</pre>
</div></li>

<li><p>
Tipos de los constructores:
</p>
<pre class="example">
λ&gt; :type Circulo
Circulo :: Float -&gt; Figura
λ&gt; :type Rect
Rect :: Float -&gt; Float -&gt; Figura
</pre></li>

<li><p>
Uso del tipo como valor: <code>(cuadrado n)</code> es el cuadrado de lado <code>n</code>.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">cuadrado</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Float</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Figura</span>
<span style="color: #0000ff;">cuadrado</span> n <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Rect</span> n n
</pre>
</div></li>

<li><p>
Uso del tipo como argumento: <code>(area f)</code> es el área de la figura <code>f</code>. Por
ejemplo,
</p>
<pre class="example">
area (Circulo 1)   ==  3.1415927
area (Circulo 2)   ==  12.566371
area (Rect 2 5)    ==  10.0
area (cuadrado 3)  ==  9.0
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">area</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Figura</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Float</span>
<span style="color: #0000ff;">area</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Circulo</span> r<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> pi<span style="color: #a0522d;">*</span>r<span style="color: #a0522d;">^</span>2
<span style="color: #0000ff;">area</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Rect</span> x y<span style="color: #707183;">)</span>  <span style="color: #a0522d;">=</span> x<span style="color: #a0522d;">*</span>y
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-orgb366772" class="outline-3">
<h3 id="orgb366772"><span class="section-number-3">2.4.</span> Definición de tipos con parámetros</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>Los tipos definidos pueden tener parámetros.</li>

<li><p>
Ejemplo de tipo con parámetro
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">Maybe</span> a <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Nothing</span> <span style="color: #a0522d;">|</span> <span style="color: #228b22;">Just</span> a
</pre>
</div></li>

<li><p>
<code>(divisionSegura m n)</code> es la división de <code>m</code> entre <code>n</code> si <code>n</code> no es cero y
nada en caso contrario. Por ejemplo,
</p>
<pre class="example">
divisionSegura 6 3  ==  Just 2
divisionSegura 6 0  ==  Nothing
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">divisionSegura</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Int</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Int</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Maybe</span> <span style="color: #228b22;">Int</span>
<span style="color: #0000ff;">divisionSegura</span> <span style="color: #a020f0;">_</span> 0 <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Nothing</span>
<span style="color: #0000ff;">divisionSegura</span> m n <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Just</span> <span style="color: #707183;">(</span>m <span style="color: #a0522d;">~</span>div<span style="color: #a0522d;">~</span> n<span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
<code>(headSegura xs)</code> es la cabeza de <code>xs</code> si <code>xs</code> es no vacía y nada en caso
contrario. Por ejemplo,
</p>
<pre class="example">
headSegura [2,3,5]  ==  Just 2
headSegura []       ==  Nothing
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">headSegura</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Maybe</span> a
<span style="color: #0000ff;">headSegura</span> <span style="color: #707183;">[]</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Nothing</span>
<span style="color: #0000ff;">headSegura</span> xs <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Just</span> <span style="color: #707183;">(</span>head xs<span style="color: #707183;">)</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgc54b6b8" class="outline-2">
<h2 id="orgc54b6b8"><span class="section-number-2">3.</span> Definición de tipos recursivos</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgc658d32" class="outline-3">
<h3 id="orgc658d32"><span class="section-number-3">3.1.</span> Definición de tipos recursivos: Los naturales</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>Los tipos definidos con <code>data</code> pueden ser recursivos.</li>

<li><p>
Los naturales se construyen con el cero y la función sucesor.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">Nat</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Cero</span> <span style="color: #a0522d;">|</span> <span style="color: #228b22;">Suc</span> <span style="color: #228b22;">Nat</span>
  <span style="color: #a020f0;">deriving</span> <span style="color: #228b22;">Show</span>
</pre>
</div></li>

<li><p>
Tipos de los constructores:
</p>
<pre class="example">
λ&gt; :type Cero
Cero :: Nat
λ&gt; :type Suc
Suc :: Nat -&gt; Nat
</pre></li>

<li><p>
Ejemplos de naturales:
</p>
<pre class="example">
Cero
Suc Cero
Suc (Suc Cero)
Suc (Suc (Suc Cero))
</pre></li>
</ul>
</div>
</div>

<div id="outline-container-orgf77dd65" class="outline-3">
<h3 id="orgf77dd65"><span class="section-number-3">3.2.</span> Definiciones con tipos recursivos</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li><p>
<code>(nat2int n)</code> es el número entero correspondiente al número natural <code>n</code>. Por
ejemplo,
</p>
<pre class="example">
nat2int (Suc (Suc (Suc Cero)))  ==  3
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">nat2int</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Nat</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Int</span>
<span style="color: #0000ff;">nat2int</span> <span style="color: #228b22;">Cero</span>    <span style="color: #a0522d;">=</span> 0
<span style="color: #0000ff;">nat2int</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Suc</span> n<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> 1 <span style="color: #a0522d;">+</span> nat2int n
</pre>
</div></li>

<li><p>
<code>(int2nat n)</code> es el número natural correspondiente al número
entero <code>n</code>. Por ejemplo,
</p>
<pre class="example">
int2nat 3  ==  Suc (Suc (Suc Cero))
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">int2nat</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Int</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Nat</span>
<span style="color: #0000ff;">int2nat</span> 0 <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Cero</span>
<span style="color: #0000ff;">int2nat</span> n <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Suc</span> <span style="color: #707183;">(</span>int2nat <span style="color: #7388d6;">(</span>n<span style="color: #a0522d;">-</span>1<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
<code>(suma m n)</code> es la suma de los número naturales <code>m</code> y
<code>n</code>. Por ejemplo,
</p>
<pre class="example">
λ&gt; suma (Suc (Suc Cero)) (Suc Cero)
Suc (Suc (Suc Cero))
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">suma</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Nat</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Nat</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Nat</span>
<span style="color: #0000ff;">suma</span> <span style="color: #228b22;">Cero</span>    n <span style="color: #a0522d;">=</span> n
<span style="color: #0000ff;">suma</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Suc</span> m<span style="color: #707183;">)</span> n <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Suc</span> <span style="color: #707183;">(</span>suma m n<span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
Ejemplo de cálculo:
</p>
<pre class="example">
suma (Suc (Suc Cero)) (Suc Cero)
= Suc (suma (Suc Cero) (Suc Cero))
= Suc (Suc (suma Cero (Suc Cero)))
= Suc (Suc (Suc Cero))
</pre></li>
</ul>
</div>
</div>

<div id="outline-container-org7663962" class="outline-3">
<h3 id="org7663962"><span class="section-number-3">3.3.</span> Tipo recursivo con parámetro: Las listas</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li><p>
Definición del tipo lista:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">Lista</span> a <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Nil</span> <span style="color: #a0522d;">|</span> <span style="color: #228b22;">Cons</span> a <span style="color: #707183;">(</span><span style="color: #228b22;">Lista</span> a<span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
<code>(longitud xs)</code> es la longitud de la lista <code>xs</code>. Por ejemplo,
</p>
<pre class="example">
longitud (Cons 2 (Cons 3 (Cons 5 Nil)))  ==  3
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">longitud</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Lista</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Int</span>
<span style="color: #0000ff;">longitud</span> <span style="color: #228b22;">Nil</span>         <span style="color: #a0522d;">=</span> 0
<span style="color: #0000ff;">longitud</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Cons</span> <span style="color: #a020f0;">_</span> xs<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> 1 <span style="color: #a0522d;">+</span> longitud xs
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-orgb3f636d" class="outline-3">
<h3 id="orgb3f636d"><span class="section-number-3">3.4.</span> Definición de tipos recursivos: Los árboles binarios</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li><p>
Ejemplo de árbol binario:
</p>
<pre class="example">
     5
    / \
   /   \
  3     7
 / \   / \
1   4 6   9
</pre></li>

<li><p>
Definición del tipo de árboles binarios:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">Arbol</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Hoja</span> <span style="color: #228b22;">Int</span> <span style="color: #a0522d;">|</span> <span style="color: #228b22;">Nodo</span> <span style="color: #228b22;">Arbol</span> <span style="color: #228b22;">Int</span> <span style="color: #228b22;">Arbol</span>
</pre>
</div></li>

<li><p>
Representación del ejemplo
</p>
<pre class="example">
ejArbol = Nodo (Nodo (Hoja 1) 3 (Hoja 4))
               5
               (Nodo (Hoja 6) 7 (Hoja 9))
</pre></li>
</ul>
</div>
</div>

<div id="outline-container-org302de78" class="outline-3">
<h3 id="org302de78"><span class="section-number-3">3.5.</span> Definiciones sobre árboles binarios</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li><p>
<code>(ocurre m a)</code> se verifica si <code>m</code> ocurre en el árbol <code>a</code>. Por ejemplo,
</p>
<pre class="example">
ocurre 4  ejArbol  ==  True
ocurre 10 ejArbol  ==  False
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">ocurre</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Int</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Arbol</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
<span style="color: #0000ff;">ocurre</span> m <span style="color: #707183;">(</span><span style="color: #228b22;">Hoja</span> n<span style="color: #707183;">)</span>     <span style="color: #a0522d;">=</span> m <span style="color: #a0522d;">==</span> n
<span style="color: #0000ff;">ocurre</span> m <span style="color: #707183;">(</span><span style="color: #228b22;">Nodo</span> i n d<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> m <span style="color: #a0522d;">==</span> n <span style="color: #a0522d;">||</span> ocurre m i <span style="color: #a0522d;">||</span> ocurre m d
</pre>
</div></li>

<li><p>
<code>(aplana a)</code> es la lista obtenida aplanando el árbol <code>a</code>. Por ejemplo,
</p>
<pre class="example">
aplana ejArbol  ==  [1,3,4,5,6,7,9]
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">aplana</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Arbol</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Int</span><span style="color: #707183;">]</span>
<span style="color: #0000ff;">aplana</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Hoja</span> n<span style="color: #707183;">)</span>     <span style="color: #a0522d;">=</span> <span style="color: #707183;">[</span>n<span style="color: #707183;">]</span>
<span style="color: #0000ff;">aplana</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Nodo</span> i n d<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> aplana i <span style="color: #a0522d;">++</span> <span style="color: #707183;">[</span>n<span style="color: #707183;">]</span> <span style="color: #a0522d;">++</span> aplana d
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org600791c" class="outline-3">
<h3 id="org600791c"><span class="section-number-3">3.6.</span> Definiciones sobre árboles binarios</h3>
<div class="outline-text-3" id="text-3-6">
<ul class="org-ul">
<li>Un árbol es ordenado si el valor de cada nodo es mayor que los de su subárbol
izquierdo y menor que los de su subárbol derecho.</li>

<li>El árbol del ejemplo es ordenado.</li>

<li><p>
<code>(ocurreEnArbolOrdenado m a)</code> se verifica si <code>m</code> ocurre en el árbol ordenado
<code>a</code>. Por ejemplo,
</p>
<pre class="example">
ocurreEnArbolOrdenado 4  ejArbol  ==  True
ocurreEnArbolOrdenado 10 ejArbol  ==  False
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">ocurreEnArbolOrdenado</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Int</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Arbol</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
<span style="color: #0000ff;">ocurreEnArbolOrdenado</span> m <span style="color: #707183;">(</span><span style="color: #228b22;">Hoja</span> n<span style="color: #707183;">)</span>  <span style="color: #a0522d;">=</span>  m <span style="color: #a0522d;">==</span> n
<span style="color: #0000ff;">ocurreEnArbolOrdenado</span> m <span style="color: #707183;">(</span><span style="color: #228b22;">Nodo</span> i n d<span style="color: #707183;">)</span>
   <span style="color: #a0522d;">|</span> m <span style="color: #a0522d;">==</span> n      <span style="color: #a0522d;">=</span>  <span style="color: #228b22;">True</span>
   <span style="color: #a0522d;">|</span> m <span style="color: #a0522d;">&lt;</span> n       <span style="color: #a0522d;">=</span>  ocurreEnArbolOrdenado m i
   <span style="color: #a0522d;">|</span> otherwise   <span style="color: #a0522d;">=</span>  ocurreEnArbolOrdenado m d
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-orge316c2e" class="outline-3">
<h3 id="orge316c2e"><span class="section-number-3">3.7.</span> Definiciones de distintos tipos de árboles</h3>
<div class="outline-text-3" id="text-3-7">
<ul class="org-ul">
<li><p>
Árboles binarios con valores en las hojas:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">Arbol</span> a <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Hoja</span> a <span style="color: #a0522d;">|</span> <span style="color: #228b22;">Nodo</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Arbol</span> a<span style="color: #707183;">)</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Arbol</span> a<span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
Árboles binarios con valores en los nodos:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">Arbol</span> a <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Hoja</span> <span style="color: #a0522d;">|</span> <span style="color: #228b22;">Nodo</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Arbol</span> a<span style="color: #707183;">)</span> a <span style="color: #707183;">(</span><span style="color: #228b22;">Arbol</span> a<span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
Árboles binarios con valores en las hojas y en los nodos:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">Arbol</span> a b <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Hoja</span> a <span style="color: #a0522d;">|</span> <span style="color: #228b22;">Nodo</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Arbol</span> a b<span style="color: #707183;">)</span> b <span style="color: #707183;">(</span><span style="color: #228b22;">Arbol</span> a b<span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
Árboles con un número variable de sucesores:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">Arbol</span> a <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Nodo</span> a <span style="color: #707183;">[</span><span style="color: #228b22;">Arbol</span> a<span style="color: #707183;">]</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org43e9373" class="outline-2">
<h2 id="org43e9373"><span class="section-number-2">4.</span> Sistema de decisión de tautologías</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org15bbeed" class="outline-3">
<h3 id="org15bbeed"><span class="section-number-3">4.1.</span> Sintaxis de la lógica proposicional</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>Definición de fórmula proposicional:
<ul class="org-ul">
<li>Las variables proposicionales son fórmulas.</li>
<li>Si F es una fórmula, entonces ¬F también lo es.</li>
<li>Si F y G son fórmulas, entonces (F ∧ G) y (F ∨ G) también lo son.</li>
</ul></li>

<li><p>
Tipo de dato de fórmulas proposicionales:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">FProp</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Const</span> <span style="color: #228b22;">Bool</span>
           <span style="color: #a0522d;">|</span> <span style="color: #228b22;">Var</span> <span style="color: #228b22;">Char</span>
           <span style="color: #a0522d;">|</span> <span style="color: #228b22;">Neg</span> <span style="color: #228b22;">FProp</span>
           <span style="color: #a0522d;">|</span> <span style="color: #228b22;">Conj</span> <span style="color: #228b22;">FProp</span> <span style="color: #228b22;">FProp</span>
           <span style="color: #a0522d;">|</span> <span style="color: #228b22;">Impl</span> <span style="color: #228b22;">FProp</span> <span style="color: #228b22;">FProp</span>
  <span style="color: #a020f0;">deriving</span> <span style="color: #228b22;">Show</span>
</pre>
</div></li>

<li><p>
Ejemplos de fórmulas proposicionales:
</p>
<ul class="org-ul">
<li>A ∧ ¬A</li>
<li>(A ∧ B) → A</li>
<li>A → (A ∧ B)</li>
<li>(A → (A → B)) → B</li>
</ul>
<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">p1, p2, p3, p4</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">FProp</span>
<span style="color: #0000ff;">p1</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Conj</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Var</span> <span style="color: #8b2252;">'A'</span><span style="color: #707183;">)</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Neg</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">Var</span> <span style="color: #8b2252;">'A'</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #0000ff;">p2</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Impl</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Conj</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">Var</span> <span style="color: #8b2252;">'A'</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">Var</span> <span style="color: #8b2252;">'B'</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Var</span> <span style="color: #8b2252;">'A'</span><span style="color: #707183;">)</span>
<span style="color: #0000ff;">p3</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Impl</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Var</span> <span style="color: #8b2252;">'A'</span><span style="color: #707183;">)</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Conj</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">Var</span> <span style="color: #8b2252;">'A'</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">Var</span> <span style="color: #8b2252;">'B'</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #0000ff;">p4</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Impl</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Conj</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">Var</span> <span style="color: #8b2252;">'A'</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">Impl</span> <span style="color: #909183;">(</span><span style="color: #228b22;">Var</span> <span style="color: #8b2252;">'A'</span><span style="color: #909183;">)</span> <span style="color: #909183;">(</span><span style="color: #228b22;">Var</span> <span style="color: #8b2252;">'B'</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
          <span style="color: #707183;">(</span><span style="color: #228b22;">Var</span> <span style="color: #8b2252;">'B'</span><span style="color: #707183;">)</span>
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-orgd1c2f0e" class="outline-3">
<h3 id="orgd1c2f0e"><span class="section-number-3">4.2.</span> Semántica de la lógica proposicional</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li><p>
Tabla de verdad de la negación:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">i</th>
<th scope="col" class="org-left">¬i</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">T</td>
<td class="org-left">F</td>
</tr>

<tr>
<td class="org-left">F</td>
<td class="org-left">T</td>
</tr>
</tbody>
</table></li>

<li><p>
Tablas de verdad de la conjunción y el condicional:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">i</th>
<th scope="col" class="org-left">j</th>
<th scope="col" class="org-left">i ∧ j</th>
<th scope="col" class="org-left">i → j</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">T</td>
<td class="org-left">T</td>
<td class="org-left">T</td>
<td class="org-left">T</td>
</tr>

<tr>
<td class="org-left">T</td>
<td class="org-left">F</td>
<td class="org-left">F</td>
<td class="org-left">F</td>
</tr>

<tr>
<td class="org-left">F</td>
<td class="org-left">T</td>
<td class="org-left">F</td>
<td class="org-left">T</td>
</tr>

<tr>
<td class="org-left">F</td>
<td class="org-left">F</td>
<td class="org-left">F</td>
<td class="org-left">T</td>
</tr>
</tbody>
</table></li>

<li><p>
Tabla de verdad para (A → B) ∨ (B → A):
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">A</th>
<th scope="col" class="org-left">B</th>
<th scope="col" class="org-left">A → B</th>
<th scope="col" class="org-left">B → A</th>
<th scope="col" class="org-left">(A → B) ∨ (B → A)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">T</td>
<td class="org-left">T</td>
<td class="org-left">T</td>
<td class="org-left">T</td>
<td class="org-left">T</td>
</tr>

<tr>
<td class="org-left">T</td>
<td class="org-left">F</td>
<td class="org-left">F</td>
<td class="org-left">T</td>
<td class="org-left">T</td>
</tr>

<tr>
<td class="org-left">F</td>
<td class="org-left">T</td>
<td class="org-left">T</td>
<td class="org-left">F</td>
<td class="org-left">T</td>
</tr>

<tr>
<td class="org-left">F</td>
<td class="org-left">F</td>
<td class="org-left">T</td>
<td class="org-left">T</td>
<td class="org-left">T</td>
</tr>
</tbody>
</table></li>

<li><p>
Las interpretaciones son listas formadas por el nombre de una variable
proposicional y un valor de verdad.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">Interpretacion</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">[</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">Char</span>, <span style="color: #228b22;">Bool</span><span style="color: #7388d6;">)</span><span style="color: #707183;">]</span>
</pre>
</div></li>

<li><p>
<code>(valor i p)</code> es el valor de la fórmula <code>p</code> en la interpretación <code>i</code>. Por
ejemplo,
</p>
<pre class="example">
valor [('A',False),('B',True)] p3  ==  True
valor [('A',True),('B',False)] p3  ==  False
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">valor</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Interpretacion</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">FProp</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
<span style="color: #0000ff;">valor</span> <span style="color: #a020f0;">_</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Const</span> b<span style="color: #707183;">)</span>  <span style="color: #a0522d;">=</span> b
<span style="color: #0000ff;">valor</span> i <span style="color: #707183;">(</span><span style="color: #228b22;">Var</span> x<span style="color: #707183;">)</span>    <span style="color: #a0522d;">=</span> busca x i
<span style="color: #0000ff;">valor</span> i <span style="color: #707183;">(</span><span style="color: #228b22;">Neg</span> p<span style="color: #707183;">)</span>    <span style="color: #a0522d;">=</span> not <span style="color: #707183;">(</span>valor i p<span style="color: #707183;">)</span>
<span style="color: #0000ff;">valor</span> i <span style="color: #707183;">(</span><span style="color: #228b22;">Conj</span> p q<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> valor i p <span style="color: #a0522d;">&amp;&amp;</span> valor i q
<span style="color: #0000ff;">valor</span> i <span style="color: #707183;">(</span><span style="color: #228b22;">Impl</span> p q<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> valor i p <span style="color: #a0522d;">&lt;=</span> valor i q
</pre>
</div></li>

<li><p>
<code>(busca c t)</code> es el valor del primer elemento de la lista de asociación <code>t</code>
cuya clave es <code>c</code>. Por ejemplo,
</p>
<pre class="example">
busca 2 [(1,'a'),(3,'d'),(2,'c')]  ==  'c'
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">busca</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Eq</span> c <span style="color: #a0522d;">=&gt;</span> c <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span><span style="color: #7388d6;">(</span>c,v<span style="color: #7388d6;">)</span><span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> v
<span style="color: #0000ff;">busca</span> c t <span style="color: #a0522d;">=</span> head <span style="color: #707183;">[</span>v <span style="color: #a0522d;">|</span> <span style="color: #7388d6;">(</span>c',v<span style="color: #7388d6;">)</span> <span style="color: #a0522d;">&lt;-</span> t, c <span style="color: #a0522d;">==</span> c'<span style="color: #707183;">]</span>
</pre>
</div></li>

<li><p>
<code>(variables p)</code> es la lista de los nombres de las variables de <code>p</code>.
</p>
<pre class="example">
variables p3  ==  "AAB"
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">variables</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">FProp</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Char</span><span style="color: #707183;">]</span>
<span style="color: #0000ff;">variables</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Const</span> <span style="color: #a020f0;">_</span><span style="color: #707183;">)</span>  <span style="color: #a0522d;">=</span> <span style="color: #707183;">[]</span>
<span style="color: #0000ff;">variables</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Var</span> x<span style="color: #707183;">)</span>    <span style="color: #a0522d;">=</span> <span style="color: #707183;">[</span>x<span style="color: #707183;">]</span>
<span style="color: #0000ff;">variables</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Neg</span> p<span style="color: #707183;">)</span>    <span style="color: #a0522d;">=</span> variables p
<span style="color: #0000ff;">variables</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Conj</span> p q<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> variables p <span style="color: #a0522d;">++</span> variables q
<span style="color: #0000ff;">variables</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Impl</span> p q<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> variables p <span style="color: #a0522d;">++</span> variables q
</pre>
</div></li>

<li><p>
<code>(interpretacionesVar n)</code> es la lista de las interpretaciones con <code>n</code>
variables. Por ejemplo,
</p>
<pre class="example">
λ&gt; interpretacionesVar 2
[[False,False],
 [False,True],
 [True,False],
 [True,True]]
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">interpretacionesVar</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Int</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span><span style="color: #7388d6;">[</span><span style="color: #228b22;">Bool</span><span style="color: #7388d6;">]</span><span style="color: #707183;">]</span>
<span style="color: #0000ff;">interpretacionesVar</span> 0 <span style="color: #a0522d;">=</span> <span style="color: #707183;">[</span><span style="color: #7388d6;">[]</span><span style="color: #707183;">]</span>
<span style="color: #0000ff;">interpretacionesVar</span> n <span style="color: #a0522d;">=</span> map <span style="color: #707183;">(</span><span style="color: #228b22;">False:</span><span style="color: #707183;">)</span> bss <span style="color: #a0522d;">++</span> map <span style="color: #707183;">(</span><span style="color: #228b22;">True:</span><span style="color: #707183;">)</span> bss
  <span style="color: #a020f0;">where</span> bss <span style="color: #a0522d;">=</span> interpretacionesVar <span style="color: #707183;">(</span>n<span style="color: #a0522d;">-</span>1<span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
<code>(interpretaciones p)</code> es la lista de las interpretaciones de la fórmula
<code>p</code>. Por ejemplo,
</p>
<pre class="example">
λ&gt; interpretaciones p3
[[('A',False),('B',False)],
 [('A',False),('B',True)],
 [('A',True),('B',False)],
 [('A',True),('B',True)]]
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">interpretaciones</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">FProp</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Interpretacion</span><span style="color: #707183;">]</span>
<span style="color: #0000ff;">interpretaciones</span> p <span style="color: #a0522d;">=</span>
  <span style="color: #707183;">[</span>zip vs i <span style="color: #a0522d;">|</span> i <span style="color: #a0522d;">&lt;-</span> interpretacionesVar <span style="color: #7388d6;">(</span>length vs<span style="color: #7388d6;">)</span><span style="color: #707183;">]</span>
  <span style="color: #a020f0;">where</span> vs <span style="color: #a0522d;">=</span> nub <span style="color: #707183;">(</span>variables p<span style="color: #707183;">)</span>
</pre>
</div></li>
</ul>

<p>
<b><b>Decisión de tautología</b></b>
</p>

<ul class="org-ul">
<li><p>
<code>(esTautologia p)</code> se verifica si la fórmula <code>p</code> es una tautología. Por
ejemplo,
</p>
<pre class="example">
esTautologia p1  ==  False
esTautologia p2  ==  True
esTautologia p3  ==  False
esTautologia p4  ==  True
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">esTautologia</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">FProp</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
<span style="color: #0000ff;">esTautologia</span> p <span style="color: #a0522d;">=</span>
  and <span style="color: #707183;">[</span>valor i p <span style="color: #a0522d;">|</span> i <span style="color: #a0522d;">&lt;-</span> interpretaciones p<span style="color: #707183;">]</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgb74b377" class="outline-2">
<h2 id="orgb74b377"><span class="section-number-2">5.</span> Máquina abstracta de cálculo aritmético</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org546cc3c" class="outline-3">
<h3 id="org546cc3c"><span class="section-number-3">5.1.</span> Evaluación de expresiones aritméticas</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li><p>
Una expresión aritmética es un número entero o la suma de dos expresiones.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">Expr</span> <span style="color: #a0522d;">=</span>  <span style="color: #228b22;">Num</span> <span style="color: #228b22;">Int</span> <span style="color: #a0522d;">|</span> <span style="color: #228b22;">Suma</span> <span style="color: #228b22;">Expr</span> <span style="color: #228b22;">Expr</span>
</pre>
</div></li>

<li><p>
<code>(valorEA x)</code> es el valor de la expresión aritmética <code>x</code>.
</p>
<pre class="example">
valorEA (Suma (Suma (Num 2) (Num 3)) (Num 4))  ==  9
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">valorEA</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Expr</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Int</span>
<span style="color: #0000ff;">valorEA</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Num</span> n<span style="color: #707183;">)</span>    <span style="color: #a0522d;">=</span> n
<span style="color: #0000ff;">valorEA</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Suma</span> x y<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> valorEA x <span style="color: #a0522d;">+</span> valorEA y
</pre>
</div></li>

<li><p>
Cálculo:
</p>
<pre class="example">
valorEA (Suma (Suma (Num 2) (Num 3)) (Num 4))
= (valorEA (Suma (Num 2) (Num 3))) + (valorEA (Num 4))
= (valorEA (Suma (Num 2) (Num 3))) + 4
= (valorEA (Num 2) + (valorEA (Num 3))) + 4
= (2 + 3) + 4
= 9
</pre></li>
</ul>
</div>
</div>

<div id="outline-container-orge561778" class="outline-3">
<h3 id="orge561778"><span class="section-number-3">5.2.</span> Máquina de cálculo aritmético</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li><p>
La pila de control de la máquina abstracta es una lista de operaciones.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">PControl</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Op</span><span style="color: #707183;">]</span>
</pre>
</div></li>

<li><p>
Las operaciones son meter una expresión en la pila o sumar un número con el
primero de la pila.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">Op</span> <span style="color: #a0522d;">=</span>  <span style="color: #228b22;">METE</span> <span style="color: #228b22;">Expr</span> <span style="color: #a0522d;">|</span> <span style="color: #228b22;">SUMA</span> <span style="color: #228b22;">Int</span>
</pre>
</div></li>

<li><p>
<code>(eval x p)</code> evalúa la expresión <code>x</code> con la pila de control <code>p</code>. Por ejemplo,
</p>
<pre class="example">
eval (Suma (Suma (Num 2) (Num 3)) (Num 4)) []  ==  9
eval (Suma (Num 2) (Num 3)) [METE (Num 4)]     ==  9
eval (Num 3) [SUMA 2, METE (Num 4)]            ==  9
eval (Num 4) [SUMA 5]                          ==  9
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">eval</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Expr</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">PControl</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Int</span>
<span style="color: #0000ff;">eval</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Num</span> n<span style="color: #707183;">)</span>    p <span style="color: #a0522d;">=</span> ejec p n
<span style="color: #0000ff;">eval</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Suma</span> x y<span style="color: #707183;">)</span> p <span style="color: #a0522d;">=</span> eval x <span style="color: #707183;">(</span><span style="color: #228b22;">METE</span> y <span style="color: #228b22;">:</span> p<span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
<code>(ejec p n)</code> ejecuta la lista de control <code>p</code> sobre el entero <code>n</code>. Por
ejemplo,
</p>
<pre class="example">
ejec [METE (Num 3), METE (Num 4)] 2  ==  9
ejec [SUMA 2, METE (Num 4)]       3  ==  9
ejec [METE (Num 4)]               5  ==  9
ejec [SUMA 5]                     4  ==  9
ejec []                           9  ==  9
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">ejec</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">PControl</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Int</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Int</span>
<span style="color: #0000ff;">ejec</span> <span style="color: #707183;">[]</span>           n <span style="color: #a0522d;">=</span> n
<span style="color: #0000ff;">ejec</span> <span style="color: #707183;">(</span><span style="color: #228b22;">METE</span> y <span style="color: #228b22;">:</span> p<span style="color: #707183;">)</span> n <span style="color: #a0522d;">=</span> eval y <span style="color: #707183;">(</span><span style="color: #228b22;">SUMA</span> n <span style="color: #228b22;">:</span> p<span style="color: #707183;">)</span>
<span style="color: #0000ff;">ejec</span> <span style="color: #707183;">(</span><span style="color: #228b22;">SUMA</span> n <span style="color: #228b22;">:</span> p<span style="color: #707183;">)</span> m <span style="color: #a0522d;">=</span> ejec p <span style="color: #707183;">(</span>n<span style="color: #a0522d;">+</span>m<span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
<code>(evalua e)</code> evalúa la expresión aritmética <code>e</code> con la máquina abstracta. Por
ejemplo,
</p>
<pre class="example">
evalua (Suma (Suma (Num 2) (Num 3)) (Num 4))  ==  9
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">evalua</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Expr</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Int</span>
<span style="color: #0000ff;">evalua</span> e <span style="color: #a0522d;">=</span> eval e <span style="color: #707183;">[]</span>
</pre>
</div></li>

<li><p>
Evaluación:
</p>
<pre class="example">
eval (Suma (Suma (Num 2) (Num 3)) (Num 4)) []
= eval (Suma (Num 2) (Num 3)) [METE (Num 4)]
= eval (Num 2) [METE (Num 3), METE (Num 4)]
= ejec [METE (Num 3), METE (Num 4)] 2
= eval (Num 3) [SUMA 2, METE (Num 4)]
= ejec [SUMA 2, METE (Num 4)] 3
= ejec [METE (Num 4)] (2+3)
= ejec [METE (Num 4)] 5
= eval (Num 4) [SUMA 5]
= ejec [SUMA 5] 4
= ejec [] (5+4)
= ejec [] 9
= 9
</pre></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org0b210d5" class="outline-2">
<h2 id="org0b210d5"><span class="section-number-2">6.</span> Declaraciones de clases y de instancias</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org18bc419" class="outline-3">
<h3 id="org18bc419"><span class="section-number-3">6.1.</span> Declaraciones de clases</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>Las clases se declaran mediante el mecanismo <code>class</code>.</li>

<li><p>
Ejemplo de declaración de clases:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Eq</span> a <span style="color: #a020f0;">where</span>
  <span style="color: #707183;">(</span><span style="color: #a0522d;">==</span><span style="color: #707183;">)</span>, <span style="color: #707183;">(</span><span style="color: #a0522d;">/=</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>

  <span style="color: #b22222;">-- </span><span style="color: #b22222;">Minimal complete definition: (==) or (/=)</span>
  x <span style="color: #a0522d;">==</span> y <span style="color: #a0522d;">=</span> not <span style="color: #707183;">(</span>x<span style="color: #a0522d;">/=</span>y<span style="color: #707183;">)</span>
  x <span style="color: #a0522d;">/=</span> y <span style="color: #a0522d;">=</span> not <span style="color: #707183;">(</span>x<span style="color: #a0522d;">==</span>y<span style="color: #707183;">)</span>
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org6ee0d83" class="outline-3">
<h3 id="org6ee0d83"><span class="section-number-3">6.2.</span> Declaraciones de instancias</h3>
<div class="outline-text-3" id="text-6-2">
<ul class="org-ul">
<li>Las instancias se declaran mediante el mecanismo <code>instance</code>.</li>

<li><p>
Ejemplo de declaración de instancia:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">instance</span> <span style="color: #228b22;">Eq</span> <span style="color: #228b22;">Bool</span> <span style="color: #a020f0;">where</span>
  <span style="color: #228b22;">False</span> <span style="color: #a0522d;">==</span> <span style="color: #228b22;">False</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">True</span>
  <span style="color: #228b22;">True</span>  <span style="color: #a0522d;">==</span> <span style="color: #228b22;">True</span>  <span style="color: #a0522d;">=</span> <span style="color: #228b22;">True</span>
  <span style="color: #a020f0;">_</span>     <span style="color: #a0522d;">==</span> <span style="color: #a020f0;">_</span>     <span style="color: #a0522d;">=</span> <span style="color: #228b22;">False</span>
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org264bb63" class="outline-3">
<h3 id="org264bb63"><span class="section-number-3">6.3.</span> Extensiones de clases</h3>
<div class="outline-text-3" id="text-6-3">
<ul class="org-ul">
<li>Las clases pueden extenderse mediante el mecanismo <code>class</code>.</li>

<li><p>
Ejemplo de extensión de clases:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">class</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Eq</span> a<span style="color: #707183;">)</span> <span style="color: #a0522d;">=&gt;</span> <span style="color: #228b22;">Ord</span> a <span style="color: #a020f0;">where</span>
  compare                <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Ordering</span>
  <span style="color: #707183;">(</span><span style="color: #a0522d;">&lt;</span><span style="color: #707183;">)</span>, <span style="color: #707183;">(</span><span style="color: #a0522d;">&lt;=</span><span style="color: #707183;">)</span>, <span style="color: #707183;">(</span><span style="color: #a0522d;">&gt;=</span><span style="color: #707183;">)</span>, <span style="color: #707183;">(</span><span style="color: #a0522d;">&gt;</span><span style="color: #707183;">)</span>   <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
  max, min               <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> a

  <span style="color: #b22222;">-- </span><span style="color: #b22222;">Minimal complete definition: (&lt;=) or compare</span>
  <span style="color: #b22222;">-- </span><span style="color: #b22222;">using compare can be more efficient for complex types</span>
  compare x y <span style="color: #a0522d;">|</span> x<span style="color: #a0522d;">==</span>y      <span style="color: #a0522d;">=</span> <span style="color: #228b22;">EQ</span>
              <span style="color: #a0522d;">|</span> x<span style="color: #a0522d;">&lt;=</span>y      <span style="color: #a0522d;">=</span> <span style="color: #228b22;">LT</span>
              <span style="color: #a0522d;">|</span> otherwise <span style="color: #a0522d;">=</span> <span style="color: #228b22;">GT</span>

  x <span style="color: #a0522d;">&lt;=</span> y                  <span style="color: #a0522d;">=</span> compare x y <span style="color: #a0522d;">/=</span> <span style="color: #228b22;">GT</span>
  x <span style="color: #a0522d;">&lt;</span>  y                  <span style="color: #a0522d;">=</span> compare x y <span style="color: #a0522d;">==</span> <span style="color: #228b22;">LT</span>
  x <span style="color: #a0522d;">&gt;=</span> y                  <span style="color: #a0522d;">=</span> compare x y <span style="color: #a0522d;">/=</span> <span style="color: #228b22;">LT</span>
  x <span style="color: #a0522d;">&gt;</span>  y                  <span style="color: #a0522d;">=</span> compare x y <span style="color: #a0522d;">==</span> <span style="color: #228b22;">GT</span>

  max x y   <span style="color: #a0522d;">|</span> x <span style="color: #a0522d;">&lt;=</span> y      <span style="color: #a0522d;">=</span> y
            <span style="color: #a0522d;">|</span> otherwise   <span style="color: #a0522d;">=</span> x
  min x y   <span style="color: #a0522d;">|</span> x <span style="color: #a0522d;">&lt;=</span> y      <span style="color: #a0522d;">=</span> x
            <span style="color: #a0522d;">|</span> otherwise   <span style="color: #a0522d;">=</span> y
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-orgaa1474b" class="outline-3">
<h3 id="orgaa1474b"><span class="section-number-3">6.4.</span> Instancias de clases extendidas</h3>
<div class="outline-text-3" id="text-6-4">
<ul class="org-ul">
<li>Las instancias de las clases extendidas pueden declararse mediante el
mecanismo <code>instance</code>.</li>

<li><p>
Ejemplo de declaración de instancia:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">instance</span> <span style="color: #228b22;">Ord</span> <span style="color: #228b22;">Bool</span> <span style="color: #a020f0;">where</span>
   <span style="color: #228b22;">False</span> <span style="color: #a0522d;">&lt;=</span> <span style="color: #a020f0;">_</span>     <span style="color: #a0522d;">=</span> <span style="color: #228b22;">True</span>
   <span style="color: #228b22;">True</span>  <span style="color: #a0522d;">&lt;=</span> <span style="color: #228b22;">True</span>  <span style="color: #a0522d;">=</span> <span style="color: #228b22;">True</span>
   <span style="color: #228b22;">True</span>  <span style="color: #a0522d;">&lt;=</span> <span style="color: #228b22;">False</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">False</span>
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-orgeb6ab81" class="outline-3">
<h3 id="orgeb6ab81"><span class="section-number-3">6.5.</span> Clases derivadas</h3>
<div class="outline-text-3" id="text-6-5">
<ul class="org-ul">
<li>Al definir un nuevo tipo con <code>data</code> puede declarse como instancia de clases
mediante el mecanismo <code>deriving</code>.</li>

<li><p>
Ejemplo de clases derivadas:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">Bool</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">False</span> <span style="color: #a0522d;">|</span> <span style="color: #228b22;">True</span>
  <span style="color: #a020f0;">deriving</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Eq</span>, <span style="color: #228b22;">Ord</span>, <span style="color: #228b22;">Read</span>, <span style="color: #228b22;">Show</span><span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
Comprobación:
</p>
<pre class="example">
False == False        ==  True
False &lt; True          ==  True
show False            ==  "False"
read "False" :: Bool  ==  False
</pre></li>

<li>Para derivar un tipo cuyos constructores tienen argumentos como derivado, los
tipos de los argumentos tienen que ser instancias de las clases derivadas.</li>

<li><p>
Ejemplo:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">Figura</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Circulo</span> <span style="color: #228b22;">Float</span> <span style="color: #a0522d;">|</span> <span style="color: #228b22;">Rect</span> <span style="color: #228b22;">Float</span> <span style="color: #228b22;">Float</span>
  <span style="color: #a020f0;">deriving</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Eq</span>, <span style="color: #228b22;">Ord</span>, <span style="color: #228b22;">Show</span><span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
Se cumple que <code>Float</code> es instancia de <code>Eq</code>, <code>Ord</code> y <code>Show</code>.
</p>
<pre class="example">
λ&gt; :info Float
...
instance Eq Float
instance Ord Float
instance Show Float
...
</pre></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgc0515eb" class="outline-2">
<h2 id="orgc0515eb"><span class="section-number-2">7.</span> Material complementario</h2>
<div class="outline-text-2" id="text-7">
<p>
El código del tema se encuentra en este <a href="https://github.com/jaalonso/I1M-Cod-Temas/blob/master/src/Tema_9.hs">enlace</a>.
</p>

<p>
Este tema también se encuentra en los siguientes formatos:
</p>
<ul class="org-ul">
<li>Como <a href="./tema-9.pdf">transparencias en PDF</a>.</li>
<li>Como <a href="https://mybinder.org/v2/gh/jaalonso/Temas_interactivos_de_PF_con_Haskell/master?filepath=temas/Tema-09.ipynb">libro interactivo en IHaskell sobre Jupyter</a>.</li>
<li>Como vídeos de clase: <a href="https://youtu.be/o-DRRF4VXyE">vídeo 1</a> y <a href="https://youtu.be/76S6DEgAWzkhttps://youtu.be/pWOdjXrkHj4">vídeo 2</a>.</li>
</ul>
</div>
</div>

<div id="outline-container-org68148e0" class="outline-2">
<h2 id="org68148e0"><span class="section-number-2">8.</span> Bibliografía</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>J. Burget <a href="http://bit.ly/1NqvlTp">The algebra (and calculus!) of algebraic data types</a>.</li>

<li>G. Hutton. <b>Programming in Haskell</b>. Cambridge University Press, 2007.
<ul class="org-ul">
<li>Cap. 10: Declaring types and classes.</li>
</ul></li>

<li>B.C. Ruiz, F. Gutiérrez, P. Guerrero y J.E. Gallardo. <b>Razonando con
Haskell</b>. Thompson, 2004.
<ul class="org-ul">
<li>Cap. 4: Definición de tipos.</li>
<li>Cap. 5: El sistema de clases de Haskell.</li>
</ul></li>

<li>S. Thompson. <b>Haskell: The Craft of Functional Programming</b>, Second Edition.
Addison-Wesley, 1999.
<ul class="org-ul">
<li>Cap. 12: Overloading and type classes.</li>
<li>Cap. 13: Checking types.</li>
<li>Cap. 14: Algebraic types.</li>
</ul></li>

<li>Wikibook. <a href="https://en.wikibooks.org/wiki/Haskell">Haskell</a>.
<ul class="org-ul">
<li><a href="https://en.wikibooks.org/wiki/Haskell/Classes_and_types">Classes and types</a>.</li>
</ul></li>

<li><a href="http://learn.hfm.io/datatypes.html">Algebraic data types</a>.</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<hr>
<center>
<p><a href="/"><i class="fa fa-home"></i></a> |
   <a href="/curso-i1m/i1m/">Inicial</a> |
   <a href="/curso-i1m/i1m/temas_apuntes_codigos.html">Temas  </a> |
   <a href="/curso-i1m/i1m/manuales.html">Manuales  </a> |
   <a href="/curso-i1m/i1m/ejercicios.html">Ejercicios  </a> |
   <a href="/curso-i1m/i1m/examenes.html">Exámenes  </a> |
   <a href="/curso-i1m/i1m/doc.html">Documentación  </a>
</p>
</center>
<div id="extras">
  <p><a href="/">José A. Alonso Jiménez</a>
  <p>Sevilla, 28 de febrero del 2025</p>
  <p><i class="fa fa-cc"></i> Licencia: <a href="https://creativecommons.org/licenses/by-nc-sa/2.5/es/">Creative Commons</a>.</p>
</div>
</div>
</body>
</html>