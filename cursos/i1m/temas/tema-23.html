<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es">
<head>
<!-- 10 de junio del 2021 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tema 23: Técnicas de diseño descendente de algoritmos</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="José A. Alonso" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../../../css/estilo-org.css" />
<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="preamble" class="status">
<p><a href="/"><i class="fa fa-home"></i></a> |
   <a href="/cursos/i1m/">Inicial</a> |
   <a href="/cursos/i1m/temas.html">Temas  </a>
</p>
</div>
<div id="content">
<h1 class="title">Tema 23: Técnicas de diseño descendente de algoritmos</h1>
<div id="table-of-contents">
<h2>&Iacute;ndice</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org514c6d8">1. La técnica de divide y vencerás</a>
<ul>
<li><a href="#org8c733d5">1.1. La ordenación por mezcla como ejemplo de DyV</a></li>
<li><a href="#orgecd8072">1.2. La ordenación rápida como ejemplo de DyV</a></li>
</ul>
</li>
<li><a href="#org56314fd">2. Búsqueda en espacios de estados</a>
<ul>
<li><a href="#org6c8fe00">2.1. El patrón de búsqueda en espacios de estados</a></li>
<li><a href="#org7867dbb">2.2. El problema de las n reinas</a></li>
<li><a href="#org401168f">2.3. El problema de la mochila</a></li>
</ul>
</li>
<li><a href="#org348e858">3. Búsqueda por primero el mejor</a>
<ul>
<li><a href="#org1381eeb">3.1. El patrón de búsqueda por primero el mejor</a></li>
<li><a href="#org8739a70">3.2. El problema del 8 puzzle</a></li>
</ul>
</li>
<li><a href="#org36af926">4. Búsqueda en escalada</a>
<ul>
<li><a href="#orga5b0311">4.1. El patrón de búsqueda en escalada</a></li>
<li><a href="#org9977d47">4.2. El problema del cambio de monedas por escalada</a></li>
<li><a href="#org048208d">4.3. El algoritmo de Prim del árbol de expansión mínimo por escalada</a></li>
</ul>
</li>
<li><a href="#org369276f">5. Material complementario</a></li>
<li><a href="#org375d8a5">6. Bibliografía</a></li>
</ul>
</div>
</div>

<div id="outline-container-org514c6d8" class="outline-2">
<h2 id="org514c6d8"><span class="section-number-2">1.</span> La técnica de divide y vencerás</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>La técnica <b>divide y vencerás</b> consta de los siguientes pasos:
<ul class="org-ul">
<li><b>Dividir</b> el problema en subproblemas menores.</li>
<li><b>Resolver</b> por separado cada uno de los subproblemas:
<ul class="org-ul">
<li>si los subproblemas son complejos, usar la misma técnica recursivamente;</li>
<li>si son simples, resolverlos directamente.</li>
</ul></li>
<li><b>Combinar</b> todas las soluciones de los subproblemas en una solución simple.</li>
</ul></li>

<li><p>
<code>(divideVenceras ind resuelve divide combina pbInicial)</code> resuelve el problema
<code>pbInicial</code> mediante la técnica de divide y vencerás, donde
</p>
<ul class="org-ul">
<li><code>(ind pb)</code> se verifica si el problema <code>pb</code> es indivisible,</li>
<li><code>(resuelve pb)</code> es la solución del problema indivisible <code>pb</code>,</li>
<li><code>(divide pb)</code> es la lista de subproblemas de <code>pb</code>,</li>
<li><code>(combina pb ss)</code> es la combinación de las soluciones <code>ss</code> de los
subproblemas del problema <code>pb</code> y</li>
<li><code>pbInicial</code> es el problema inicial.</li>
</ul>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">module</span> <span style="color: #228b22;">DivideVenceras</span> <span style="color: #707183;">(</span>divideVenceras<span style="color: #707183;">)</span> <span style="color: #a020f0;">where</span>

<span style="color: #0000ff;">divideVenceras</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">(</span>p <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">(</span>p <span style="color: #a0522d;">-&gt;</span> s<span style="color: #707183;">)</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">(</span>p <span style="color: #a0522d;">-&gt;</span> <span style="color: #7388d6;">[</span>p<span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>
                  <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">(</span>p <span style="color: #a0522d;">-&gt;</span> <span style="color: #7388d6;">[</span>s<span style="color: #7388d6;">]</span> <span style="color: #a0522d;">-&gt;</span> s<span style="color: #707183;">)</span> <span style="color: #a0522d;">-&gt;</span> p <span style="color: #a0522d;">-&gt;</span> s
<span style="color: #0000ff;">divideVenceras</span> ind resuelve divide combina pbInicial <span style="color: #a0522d;">=</span>
    dv' pbInicial <span style="color: #a020f0;">where</span>
    dv' pb
        <span style="color: #a0522d;">|</span> ind pb    <span style="color: #a0522d;">=</span> resuelve pb
        <span style="color: #a0522d;">|</span> otherwise <span style="color: #a0522d;">=</span> combina pb <span style="color: #707183;">[</span>dv' sp <span style="color: #a0522d;">|</span> sp <span style="color: #a0522d;">&lt;-</span> divide pb<span style="color: #707183;">]</span>
</pre>
</div></li>
</ul>
</div>

<div id="outline-container-org8c733d5" class="outline-3">
<h3 id="org8c733d5"><span class="section-number-3">1.1.</span> La ordenación por mezcla como ejemplo de DyV</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li><p>
<code>(ordenaPorMezcla xs)</code> es la lista obtenida ordenando <code>xs</code> por el
procedimiento de ordenación por mezcla. Por ejemplo,
</p>
<pre class="example">
λ&gt; ordenaPorMezcla [3,1,4,1,5,9,2,8]
[1,1,2,3,4,5,8,9]
</pre>

<p>
La definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">import</span> <span style="color: #228b22;">I1M.DivideVenceras</span>

<span style="color: #0000ff;">ordenaPorMezcla</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Ord</span> a <span style="color: #a0522d;">=&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span>
<span style="color: #0000ff;">ordenaPorMezcla</span> xs <span style="color: #a0522d;">=</span>
    divideVenceras ind id divide combina xs
    <span style="color: #a020f0;">where</span>
      ind xs            <span style="color: #a0522d;">=</span> length xs <span style="color: #a0522d;">&lt;=</span> 1
      divide xs         <span style="color: #a0522d;">=</span> <span style="color: #707183;">[</span>take n xs, drop n xs<span style="color: #707183;">]</span>
                          <span style="color: #a020f0;">where</span> n <span style="color: #a0522d;">=</span> length xs <span style="color: #a0522d;">`div`</span> 2
      combina <span style="color: #a020f0;">_</span> <span style="color: #707183;">[</span>l1,l2<span style="color: #707183;">]</span> <span style="color: #a0522d;">=</span> mezcla l1 l2
</pre>
</div></li>

<li><p>
<code>(mezcla xs ys)</code> es la lista obtenida mezclando <code>xs</code> e <code>ys</code>. Por ejemplo,
</p>
<pre class="example">
mezcla [1,3] [2,4,6]  ==  [1,2,3,4,6]
</pre>

<p>
Su Definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">mezcla</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Ord</span> a <span style="color: #a0522d;">=&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span>
<span style="color: #0000ff;">mezcla</span> <span style="color: #707183;">[]</span> b <span style="color: #a0522d;">=</span> b
<span style="color: #0000ff;">mezcla</span> a <span style="color: #707183;">[]</span> <span style="color: #a0522d;">=</span> a
<span style="color: #0000ff;">mezcla</span> a<span style="color: #a0522d;">@</span><span style="color: #707183;">(</span>x<span style="color: #228b22;">:</span>xs<span style="color: #707183;">)</span> b<span style="color: #a0522d;">@</span><span style="color: #707183;">(</span>y<span style="color: #228b22;">:</span>ys<span style="color: #707183;">)</span> <span style="color: #a0522d;">|</span> x <span style="color: #a0522d;">&lt;=</span> y    <span style="color: #a0522d;">=</span> x <span style="color: #228b22;">:</span> <span style="color: #707183;">(</span>mezcla xs b<span style="color: #707183;">)</span>
                         <span style="color: #a0522d;">|</span> otherwise <span style="color: #a0522d;">=</span> y <span style="color: #228b22;">:</span> <span style="color: #707183;">(</span>mezcla a ys<span style="color: #707183;">)</span>
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-orgecd8072" class="outline-3">
<h3 id="orgecd8072"><span class="section-number-3">1.2.</span> La ordenación rápida como ejemplo de DyV</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li><p>
<code>(ordenaRapida xs)</code> es la lista obtenida ordenando <code>xs</code> por el procedimiento
de ordenación rápida. Por ejemplo,
</p>
<pre class="example">
λ&gt; ordenaRapida [3,1,4,1,5,9,2,8]
[1,1,2,3,4,5,8,9]
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">import</span> <span style="color: #228b22;">I1M.DivideVenceras</span>

<span style="color: #0000ff;">ordenaRapida</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Ord</span> a <span style="color: #a0522d;">=&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span>
<span style="color: #0000ff;">ordenaRapida</span> xs <span style="color: #a0522d;">=</span>
    divideVenceras ind id divide combina xs
    <span style="color: #a020f0;">where</span>
      ind xs                <span style="color: #a0522d;">=</span> length xs <span style="color: #a0522d;">&lt;=</span> 1
      divide <span style="color: #707183;">(</span>x<span style="color: #228b22;">:</span>xs<span style="color: #707183;">)</span>         <span style="color: #a0522d;">=</span> <span style="color: #707183;">[</span><span style="color: #7388d6;">[</span> y <span style="color: #a0522d;">|</span> y <span style="color: #a0522d;">&lt;-</span> xs, y <span style="color: #a0522d;">&lt;=</span> x<span style="color: #7388d6;">]</span>,
                               <span style="color: #7388d6;">[</span> y <span style="color: #a0522d;">|</span> y <span style="color: #a0522d;">&lt;-</span> xs, y <span style="color: #a0522d;">&gt;</span> x<span style="color: #7388d6;">]</span><span style="color: #707183;">]</span>
      combina <span style="color: #707183;">(</span>x<span style="color: #228b22;">:</span><span style="color: #a020f0;">_</span><span style="color: #707183;">)</span> <span style="color: #707183;">[</span>l1,l2<span style="color: #707183;">]</span> <span style="color: #a0522d;">=</span> l1 <span style="color: #a0522d;">++</span> <span style="color: #707183;">[</span>x<span style="color: #707183;">]</span> <span style="color: #a0522d;">++</span> l2
</pre>
</div></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org56314fd" class="outline-2">
<h2 id="org56314fd"><span class="section-number-2">2.</span> Búsqueda en espacios de estados</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org6c8fe00" class="outline-3">
<h3 id="org6c8fe00"><span class="section-number-3">2.1.</span> El patrón de búsqueda en espacios de estados</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>Las características de los problemas de espacios de estados son:
<ul class="org-ul">
<li>un conjunto de las posibles situaciones o <b>nodos</b> que constituye el <b>espacio
de estados</b> (estos son las potenciales soluciones que se necesitan
explorar),</li>
<li>un conjunto de movimientos de un nodo a otros nodos, llamados los
<b>sucesores</b> del nodo,</li>
<li>un <b>nodo inicial</b> y</li>
<li>un <b>nodo objetivo</b> que es la solución.</li>
</ul></li>

<li>Se supone que el grafo implícito de espacios de estados es acíclico.</li>

<li><p>
<code>(buscaEE s o e)</code> es la lista de soluciones del problema de espacio de estado
definido por la función sucesores (<code>s</code>), el objetivo (<code>o</code>) y estado inicial
(<code>e</code>).
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">module</span> <span style="color: #228b22;">BusquedaEnEspaciosDeEstados</span> <span style="color: #707183;">(</span>buscaEE<span style="color: #707183;">)</span> <span style="color: #a020f0;">where</span>
<span style="color: #a020f0;">import</span> <span style="color: #228b22;">I1M.Pila</span>

buscaEE<span style="color: #a0522d;">::</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Eq</span> nodo<span style="color: #707183;">)</span> <span style="color: #a0522d;">=&gt;</span> <span style="color: #707183;">(</span>nodo <span style="color: #a0522d;">-&gt;</span> <span style="color: #7388d6;">[</span>nodo<span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>  <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">(</span>nodo <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span><span style="color: #707183;">)</span>
                       <span style="color: #a0522d;">-&gt;</span> nodo <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>nodo<span style="color: #707183;">]</span>
<span style="color: #0000ff;">buscaEE</span> sucesores esFinal x <span style="color: #a0522d;">=</span> busca' <span style="color: #707183;">(</span>apila x vacia<span style="color: #707183;">)</span>
 <span style="color: #a020f0;">where</span> busca' p
  <span style="color: #a0522d;">|</span> esVacia p        <span style="color: #a0522d;">=</span> <span style="color: #707183;">[]</span>
  <span style="color: #a0522d;">|</span> esFinal <span style="color: #707183;">(</span>cima p<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> cima p <span style="color: #228b22;">:</span> busca' <span style="color: #707183;">(</span>desapila p<span style="color: #707183;">)</span>
  <span style="color: #a0522d;">|</span> otherwise        <span style="color: #a0522d;">=</span> busca' <span style="color: #707183;">(</span>foldr apila <span style="color: #7388d6;">(</span>desapila p<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">(</span>sucesores x<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
  <span style="color: #a020f0;">where</span> x <span style="color: #a0522d;">=</span> cima p
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org7867dbb" class="outline-3">
<h3 id="org7867dbb"><span class="section-number-3">2.2.</span> El problema de las n reinas</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>El problema de las n reinas consiste en colocar n reinas en un tablero
cuadrado de dimensiones n por n de forma que no se encuentren más de una en la
misma línea: horizontal, vertical o diagonal.</li>

<li><p>
Se resolverá mediante búsqueda en espacio de estados
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">import</span> <span style="color: #228b22;">I1M.BusquedaEnEspaciosDeEstados</span>
</pre>
</div></li>

<li><p>
Las posiciones de las reinas en el tablero se representan por su columna
y su fila.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">Columna</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Int</span>
<span style="color: #a020f0;">type</span> <span style="color: #228b22;">Fila</span>    <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Int</span>
</pre>
</div></li>

<li><p>
Una solución de las n reinas es una lista de posiciones.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">SolNR</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">[</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">Columna</span>,<span style="color: #228b22;">Fila</span><span style="color: #7388d6;">)</span><span style="color: #707183;">]</span>
</pre>
</div></li>

<li><p>
<code>(valida sp p)</code> se verifica si la posición <code>p</code> es válida respecto de la
solución parcial <code>sp</code>; es decir, la reina en la posición <code>p</code> no amenaza a
ninguna de las reinas de la <code>sp</code> (se supone que están en distintas
columnas). Por ejemplo,
</p>
<pre class="example">
valida [(1,1)] (2,2)  ==  False
valida [(1,1)] (2,3)  ==  True
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">valida</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">SolNR</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Columna</span>,<span style="color: #228b22;">Fila</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
<span style="color: #0000ff;">valida</span> solp <span style="color: #707183;">(</span>c,r<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> and <span style="color: #707183;">[</span>test s <span style="color: #a0522d;">|</span> s <span style="color: #a0522d;">&lt;-</span> solp<span style="color: #707183;">]</span>
  <span style="color: #a020f0;">where</span> test <span style="color: #707183;">(</span>c',r'<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> and <span style="color: #707183;">[</span>c'<span style="color: #a0522d;">+</span>r'<span style="color: #a0522d;">/=</span>c<span style="color: #a0522d;">+</span>r,
                            c'<span style="color: #a0522d;">-</span>r'<span style="color: #a0522d;">/=</span>c<span style="color: #a0522d;">-</span>r,
                            r'<span style="color: #a0522d;">/=</span>r<span style="color: #707183;">]</span>
</pre>
</div></li>

<li><p>
Los nodos del problema de las n reinas son ternas formadas por la columna de
la siguiente reina, el número de columnas del tablero y la solución parcial de
las reinas colocadas anteriormente.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">NodoNR</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Columna</span>,<span style="color: #228b22;">Columna</span>,<span style="color: #228b22;">SolNR</span><span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
<code>(sucesoresNR e)</code> es la lista de los sucesores del estado <code>e</code> en el problema
de las n reinas. Por ejemplo,
</p>
<pre class="example">
λ&gt; sucesoresNR (1,4,[])
[(2,4,[(1,1)]),(2,4,[(1,2)]),(2,4,[(1,3)]),(2,4,[(1,4)])]
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">sucesoresNR</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">NodoNR</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span><span style="color: #228b22;">NodoNR</span><span style="color: #707183;">]</span>
<span style="color: #0000ff;">sucesoresNR</span> <span style="color: #707183;">(</span>c,n,solp<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span>
  <span style="color: #707183;">[</span><span style="color: #7388d6;">(</span>c<span style="color: #a0522d;">+</span>1,n,solp<span style="color: #a0522d;">++</span><span style="color: #909183;">[</span><span style="color: #709870;">(</span>c,r<span style="color: #709870;">)</span><span style="color: #909183;">]</span><span style="color: #7388d6;">)</span> <span style="color: #a0522d;">|</span> r <span style="color: #a0522d;">&lt;-</span> <span style="color: #7388d6;">[</span>1<span style="color: #a0522d;">..</span>n<span style="color: #7388d6;">]</span>,
                           valida solp <span style="color: #7388d6;">(</span>c,r<span style="color: #7388d6;">)</span><span style="color: #707183;">]</span>
</pre>
</div></li>

<li><p>
<code>(esFinalNR e)</code> se verifica si <code>e</code> es un estado final del problema de las n
reinas.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">esFinalNR</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">NodoNR</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
<span style="color: #0000ff;">esFinalNR</span> <span style="color: #707183;">(</span>c,n,solp<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> c <span style="color: #a0522d;">&gt;</span> n
</pre>
</div></li>

<li><p>
<code>(buscaEE_NR n)</code> es la primera solución del problema de las n reinas, por
búsqueda en espacio de estados. Por ejemplo,
</p>
<pre class="example">
λ&gt; buscaEE_NR 8
[(1,1),(2,5),(3,8),(4,6),(5,3),(6,7),(7,2),(8,4)]
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">buscaEE_NR</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Columna</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">SolNR</span>
<span style="color: #0000ff;">buscaEE_NR</span> n <span style="color: #a0522d;">=</span> s
  <span style="color: #a020f0;">where</span> <span style="color: #707183;">(</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">_</span>,<span style="color: #a020f0;">_</span>,s<span style="color: #7388d6;">)</span><span style="color: #228b22;">:</span><span style="color: #a020f0;">_</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> buscaEE sucesoresNR
                              esFinalNR
                              <span style="color: #707183;">(</span>1,n,<span style="color: #7388d6;">[]</span><span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
<code>(nSolucionesNR n)</code> es el número de soluciones del problema de las n reinas,
por búsqueda en espacio de estados. Por ejemplo,
</p>
<pre class="example">
nSolucionesNR 8  ==  92
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">nSolucionesNR</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Columna</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Int</span>
<span style="color: #0000ff;">nSolucionesNR</span> n <span style="color: #a0522d;">=</span>
  length <span style="color: #707183;">(</span>buscaEE sucesoresNR
                  esFinalNR
                  <span style="color: #7388d6;">(</span>1,n,<span style="color: #909183;">[]</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org401168f" class="outline-3">
<h3 id="org401168f"><span class="section-number-3">2.3.</span> El problema de la mochila</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>Se tiene una mochila de capacidad de peso p y una lista de n objetos para
colocar en la mochila. Cada objeto i tiene un peso w(i) y un valor
v(i). Considerando la posibilidad de colocar el mismo objeto varias veces en
la mochila, el problema consiste en determinar la forma de colocar los objetos
en la mochila sin sobrepasar la capacidad de la mochila colocando el máximo
valor posible.</li>

<li><p>
Se resolverá mediante búsqueda en espacio de estados
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">import</span> <span style="color: #228b22;">I1M.BusquedaEnEspaciosDeEstados</span>
<span style="color: #a020f0;">import</span> <span style="color: #228b22;">Data.List</span> <span style="color: #707183;">(</span>sort<span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
Los pesos son número enteros.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">Peso</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Int</span>
</pre>
</div></li>

<li><p>
Los valores son números reales.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">Valor</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Float</span>
</pre>
</div></li>

<li><p>
Los objetos son pares formado por un peso y un valor.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">Objeto</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Peso</span>,<span style="color: #228b22;">Valor</span><span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
Una solución del problema de la mochila es una lista de objetos.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">SolMoch</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Objeto</span><span style="color: #707183;">]</span>
</pre>
</div></li>

<li><p>
Los estados del problema de la mochila son 5-tuplas de la forma
<code>(v,p,l,o,s)</code> donde
</p>
<ul class="org-ul">
<li><code>v</code> es el valor de los objetos colocados,</li>
<li><code>p</code> es el peso de los objetos colocados,</li>
<li><code>l</code> es el límite de la capacidad de la mochila,</li>
<li><code>o</code> es la lista de los objetos colocados (ordenados de forma creciente según
sus pesos) y</li>
<li><code>s</code> es la solución parcial.</li>
</ul>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">NodoMoch</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Valor</span>,<span style="color: #228b22;">Peso</span>,<span style="color: #228b22;">Peso</span>,<span style="color: #7388d6;">[</span><span style="color: #228b22;">Objeto</span><span style="color: #7388d6;">]</span>,<span style="color: #228b22;">SolMoch</span><span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
<code>(sucesoresMoch e)</code> es la lista de los sucesores del estado <code>e</code> en el
problema de la mochila.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">sucesoresMoch</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">NodoMoch</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span><span style="color: #228b22;">NodoMoch</span><span style="color: #707183;">]</span>
<span style="color: #0000ff;">sucesoresMoch</span> <span style="color: #707183;">(</span>v,p,limite,objetos,solp<span style="color: #707183;">)</span>
    <span style="color: #a0522d;">=</span> <span style="color: #707183;">[</span><span style="color: #7388d6;">(</span> v<span style="color: #a0522d;">+</span>v',
         p<span style="color: #a0522d;">+</span>p',
         limite,
         <span style="color: #909183;">[</span>o <span style="color: #a0522d;">|</span> o<span style="color: #a0522d;">@</span><span style="color: #709870;">(</span>p'',<span style="color: #a020f0;">_</span><span style="color: #709870;">)</span> <span style="color: #a0522d;">&lt;-</span> objetos,<span style="color: #709870;">(</span>p''<span style="color: #a0522d;">&gt;=</span>p'<span style="color: #709870;">)</span><span style="color: #909183;">]</span>,
         <span style="color: #909183;">(</span>p',v'<span style="color: #909183;">)</span><span style="color: #228b22;">:</span>solp <span style="color: #7388d6;">)</span>
       <span style="color: #a0522d;">|</span> <span style="color: #7388d6;">(</span>p',v'<span style="color: #7388d6;">)</span> <span style="color: #a0522d;">&lt;-</span> objetos,
         p<span style="color: #a0522d;">+</span>p' <span style="color: #a0522d;">&lt;=</span> limite<span style="color: #707183;">]</span>
</pre>
</div></li>

<li><p>
<code>(esObjetivoMoch e)</code> se verifica si <code>e</code> es un estado final el problema de la
mochila.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">esObjetivoMoch</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">NodoMoch</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
<span style="color: #0000ff;">esObjetivoMoch</span> <span style="color: #707183;">(</span><span style="color: #a020f0;">_</span>,p,limite,<span style="color: #7388d6;">(</span><span style="color: #909183;">(</span>p',<span style="color: #a020f0;">_</span><span style="color: #909183;">)</span><span style="color: #228b22;">:</span><span style="color: #a020f0;">_</span><span style="color: #7388d6;">)</span>,<span style="color: #a020f0;">_</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span>
  p<span style="color: #a0522d;">+</span>p'<span style="color: #a0522d;">&gt;</span>limite
</pre>
</div></li>

<li><p>
<code>(buscaEE_Mochila os l)</code> es la solución del problema de la mochila para la
lista de objetos <code>os</code> y el límite de capacidad <code>l</code>. Por ejemplo,
</p>
<pre class="example">
&gt; buscaEE_Mochila [(2,3),(3,5),(4,6),(5,10)] 8
([(5,10.0),(3,5.0)],15.0)
&gt; buscaEE_Mochila [(2,3),(3,5),(5,6)] 10
([(3,5.0),(3,5.0),(2,3.0),(2,3.0)],16.0)
&gt; buscaEE_Mochila [(2,2.8),(3,4.4),(5,6.1)] 10
([(3,4.4),(3,4.4),(2,2.8),(2,2.8)],14.4)
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">buscaEE_Mochila</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Objeto</span><span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Peso</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">(</span><span style="color: #228b22;">SolMoch</span>,<span style="color: #228b22;">Valor</span><span style="color: #707183;">)</span>
<span style="color: #0000ff;">buscaEE_Mochila</span> objetos limite <span style="color: #a0522d;">=</span> <span style="color: #707183;">(</span>sol,v<span style="color: #707183;">)</span>
  <span style="color: #a020f0;">where</span> <span style="color: #707183;">(</span>v,<span style="color: #a020f0;">_</span>,<span style="color: #a020f0;">_</span>,<span style="color: #a020f0;">_</span>,sol<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> maximum <span style="color: #707183;">(</span>buscaEE sucesoresMoch
                                         esObjetivoMoch
                                         <span style="color: #7388d6;">(</span>0,0,limite,sort objetos,<span style="color: #909183;">[]</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org348e858" class="outline-2">
<h2 id="org348e858"><span class="section-number-2">3.</span> Búsqueda por primero el mejor</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org1381eeb" class="outline-3">
<h3 id="org1381eeb"><span class="section-number-3">3.1.</span> El patrón de búsqueda por primero el mejor</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li><p>
<code>(buscaPM s o e)</code> es la lista de soluciones del problema de espacio de estado
definido por la función sucesores (<code>s</code>), el objetivo (<code>o</code>) y estado inicial
(<code>e</code>), obtenidas buscando por primero el mejor.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">module</span> <span style="color: #228b22;">BusquedaPrimeroElMejor</span> <span style="color: #707183;">(</span>buscaPM<span style="color: #707183;">)</span>  <span style="color: #a020f0;">where</span>
<span style="color: #a020f0;">import</span> <span style="color: #228b22;">I1M.ColaDePrioridad</span>

<span style="color: #0000ff;">buscaPM</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Ord</span> nodo<span style="color: #707183;">)</span> <span style="color: #a0522d;">=&gt;</span>
           <span style="color: #707183;">(</span>nodo <span style="color: #a0522d;">-&gt;</span> <span style="color: #7388d6;">[</span>nodo<span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>   <span style="color: #b22222;">-- </span><span style="color: #b22222;">sucesores</span>
           <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">(</span>nodo <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span><span style="color: #707183;">)</span>  <span style="color: #b22222;">-- </span><span style="color: #b22222;">esFinal</span>
           <span style="color: #a0522d;">-&gt;</span> nodo            <span style="color: #b22222;">-- </span><span style="color: #b22222;">nodo actual</span>
           <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>nodo<span style="color: #707183;">]</span>          <span style="color: #b22222;">-- </span><span style="color: #b22222;">soluci&#243;n</span>
<span style="color: #0000ff;">buscaPM</span> sucesores esFinal x <span style="color: #a0522d;">=</span> busca' <span style="color: #707183;">(</span>inserta x vacia<span style="color: #707183;">)</span>
  <span style="color: #a020f0;">where</span>
    busca' c
      <span style="color: #a0522d;">|</span> esVacia c <span style="color: #a0522d;">=</span> <span style="color: #707183;">[]</span>
      <span style="color: #a0522d;">|</span> esFinal <span style="color: #707183;">(</span>primero c<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">(</span>primero c<span style="color: #707183;">)</span><span style="color: #228b22;">:</span><span style="color: #707183;">(</span>busca' <span style="color: #7388d6;">(</span>resto c<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
      <span style="color: #a0522d;">|</span> otherwise           <span style="color: #a0522d;">=</span> busca' <span style="color: #707183;">(</span>foldr inserta <span style="color: #7388d6;">(</span>resto c<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">(</span>sucesores x<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
      <span style="color: #a020f0;">where</span> x <span style="color: #a0522d;">=</span> primero c
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org8739a70" class="outline-3">
<h3 id="org8739a70"><span class="section-number-3">3.2.</span> El problema del 8 puzzle</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li><p>
Para el 8-puzzle se usa un cajón cuadrado en el que hay situados 8 bloques
cuadrados.  El cuadrado restante está sin rellenar. Cada bloque tiene un
número. Un bloque adyacente al hueco puede deslizarse hacia él. El juego
consiste en transformar la posición inicial en la posición final mediante el
deslizamiento de los bloques. En particular, consideramos el estado inicial y
final siguientes:
</p>
<pre class="example">
+---+---+---+                   +---+---+---+
| 2 | 6 | 3 |                   | 1 | 2 | 3 |
+---+---+---+                   +---+---+---+
| 5 |   | 4 |                   | 8 |   | 4 |
+---+---+---+                   +---+---+---+
| 1 | 7 | 8 |                   | 7 | 6 | 5 |
+---+---+---+                   +---+---+---+
Estado inicial                  Estado final
</pre></li>

<li><p>
Se resolverá mediante primero el mejor.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">import</span> <span style="color: #228b22;">I1M.BusquedaPrimeroElMejor</span>
<span style="color: #a020f0;">import</span> <span style="color: #228b22;">Data.Array</span>
</pre>
</div></li>

<li><p>
Una posición es un par de enteros.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">Posicion</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Int</span>,<span style="color: #228b22;">Int</span><span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
Un tablero es un vector de posiciones, en el que el índice indica el elemento
que ocupa la posición.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">Tablero</span>  <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Array</span> <span style="color: #228b22;">Int</span> <span style="color: #228b22;">Posicion</span>
</pre>
</div></li>

<li><p>
<code>inicial8P</code> es el estado inicial del 8 puzzle. En el ejemplo es
</p>
<pre class="example">
+---+---+---+
| 2 | 6 | 3 |
+---+---+---+
| 5 |   | 4 |
+---+---+---+
| 1 | 7 | 8 |
+---+---+---+
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">inicial8P</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Tablero</span>
<span style="color: #0000ff;">inicial8P</span> <span style="color: #a0522d;">=</span> array <span style="color: #707183;">(</span>0,8<span style="color: #707183;">)</span> <span style="color: #707183;">[</span><span style="color: #7388d6;">(</span>2,<span style="color: #909183;">(</span>1,3<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>,<span style="color: #7388d6;">(</span>6,<span style="color: #909183;">(</span>2,3<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>,<span style="color: #7388d6;">(</span>3,<span style="color: #909183;">(</span>3,3<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>,
                         <span style="color: #7388d6;">(</span>5,<span style="color: #909183;">(</span>1,2<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>,<span style="color: #7388d6;">(</span>0,<span style="color: #909183;">(</span>2,2<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>,<span style="color: #7388d6;">(</span>4,<span style="color: #909183;">(</span>3,2<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>,
                         <span style="color: #7388d6;">(</span>1,<span style="color: #909183;">(</span>1,1<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>,<span style="color: #7388d6;">(</span>7,<span style="color: #909183;">(</span>2,1<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>,<span style="color: #7388d6;">(</span>8,<span style="color: #909183;">(</span>3,1<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">]</span>
</pre>
</div></li>

<li><p>
<code>final8P</code> es el estado final del 8 puzzle. En el ejemplo es
</p>
<pre class="example">
+---+---+---+
| 1 | 2 | 3 |
+---+---+---+
| 8 |   | 4 |
+---+---+---+
| 7 | 6 | 5 |
+---+---+---+
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">final8P</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Tablero</span>
<span style="color: #0000ff;">final8P</span> <span style="color: #a0522d;">=</span> array <span style="color: #707183;">(</span>0,8<span style="color: #707183;">)</span> <span style="color: #707183;">[</span><span style="color: #7388d6;">(</span>1,<span style="color: #909183;">(</span>1,3<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>,<span style="color: #7388d6;">(</span>2,<span style="color: #909183;">(</span>2,3<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>,<span style="color: #7388d6;">(</span>3,<span style="color: #909183;">(</span>3,3<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>,
                       <span style="color: #7388d6;">(</span>8,<span style="color: #909183;">(</span>1,2<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>,<span style="color: #7388d6;">(</span>0,<span style="color: #909183;">(</span>2,2<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>,<span style="color: #7388d6;">(</span>4,<span style="color: #909183;">(</span>3,2<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>,
                       <span style="color: #7388d6;">(</span>7,<span style="color: #909183;">(</span>1,1<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>,<span style="color: #7388d6;">(</span>6,<span style="color: #909183;">(</span>2,1<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>,<span style="color: #7388d6;">(</span>5,<span style="color: #909183;">(</span>3,1<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">]</span>
</pre>
</div></li>

<li><p>
<code>(distancia p1 p2)</code> es la distancia Manhatan entre las posiciones <code>p1</code> y
<code>p2</code>. Por ejemplo,
</p>
<pre class="example">
distancia (2,7) (4,1)  ==  8
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">distancia</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Posicion</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Posicion</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Int</span>
<span style="color: #0000ff;">distancia</span> <span style="color: #707183;">(</span>x1,y1<span style="color: #707183;">)</span> <span style="color: #707183;">(</span>x2,y2<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> abs <span style="color: #707183;">(</span>x1<span style="color: #a0522d;">-</span>x2<span style="color: #707183;">)</span> <span style="color: #a0522d;">+</span> abs <span style="color: #707183;">(</span>y1<span style="color: #a0522d;">-</span>y2<span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
<code>(adyacente p1 p2)</code> se verifica si las posiciones <code>p1</code> y <code>p2</code> son
adyacentes. Por ejemplo,
</p>
<pre class="example">
adyacente (3,2) (3,1)  ==  True
adyacente (3,2) (1,2)  ==  False
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">adyacente</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Posicion</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Posicion</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
<span style="color: #0000ff;">adyacente</span> p1 p2 <span style="color: #a0522d;">=</span> distancia p1 p2 <span style="color: #a0522d;">==</span> 1
</pre>
</div></li>

<li><p>
<code>(todosMovimientos t)</code> es la lista de los tableros obtenidos aplicándole al
tablero <code>t</code> todos los posibles movimientos; es decir, intercambiando la
posición del hueco con sus adyacentes.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">todosMovimientos</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Tablero</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Tablero</span><span style="color: #707183;">]</span>
<span style="color: #0000ff;">todosMovimientos</span> t <span style="color: #a0522d;">=</span>
  <span style="color: #707183;">[</span>t<span style="color: #a0522d;">//</span><span style="color: #7388d6;">[</span><span style="color: #909183;">(</span>0,t<span style="color: #a0522d;">!</span>i<span style="color: #909183;">)</span>,<span style="color: #909183;">(</span>i,t<span style="color: #a0522d;">!</span>0<span style="color: #909183;">)</span><span style="color: #7388d6;">]</span> <span style="color: #a0522d;">|</span> i<span style="color: #a0522d;">&lt;-</span><span style="color: #7388d6;">[</span>1<span style="color: #a0522d;">..</span>8<span style="color: #7388d6;">]</span>,
                          adyacente <span style="color: #7388d6;">(</span>t<span style="color: #a0522d;">!</span>0<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">(</span>t<span style="color: #a0522d;">!</span>i<span style="color: #7388d6;">)</span><span style="color: #707183;">]</span>
</pre>
</div></li>

<li><p>
Los nodos del espacio de estados son listas de tableros [t(n), &#x2026;,t(1)] tal
que t(i) es un sucesor de t(i-1).
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">Tableros</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Est</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Tablero</span><span style="color: #707183;">]</span> <span style="color: #a020f0;">deriving</span> <span style="color: #228b22;">Show</span>
</pre>
</div></li>

<li><p>
<code>(sucesores8P e)</code> es la lista de sucesores del estado <code>e</code>.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">sucesores8P</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Tableros</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Tableros</span><span style="color: #707183;">]</span>
<span style="color: #0000ff;">sucesores8P</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Est</span><span style="color: #7388d6;">(</span>n<span style="color: #a0522d;">@</span><span style="color: #909183;">(</span>t<span style="color: #228b22;">:</span>ts<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span>
  <span style="color: #707183;">[</span><span style="color: #228b22;">Est</span> <span style="color: #7388d6;">(</span>t'<span style="color: #228b22;">:</span>n<span style="color: #7388d6;">)</span> <span style="color: #a0522d;">|</span> t' <span style="color: #a0522d;">&lt;-</span> todosMovimientos t,
                t' <span style="color: #a0522d;">`notElem`</span> ts<span style="color: #707183;">]</span>
</pre>
</div></li>

<li><p>
<code>(esFinal8P n)</code> se verifica si <code>e</code> es un nodo final del 8 puzzle.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">esFinal8P</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Tableros</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
<span style="color: #0000ff;">esFinal8P</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Est</span> <span style="color: #7388d6;">(</span>t<span style="color: #228b22;">:</span><span style="color: #a020f0;">_</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> t <span style="color: #a0522d;">==</span> final8P
</pre>
</div></li>

<li><p>
<code>(heur1 t)</code> es la suma de la distancia Manhatan desde la posición de cada
objeto del tablero <code>t</code> a su posición en el estado final. Por ejemplo,
</p>
<pre class="example">
heur1 inicial8P  ==  12
</pre>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">heur1</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Tablero</span>  <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Int</span>
<span style="color: #0000ff;">heur1</span> t <span style="color: #a0522d;">=</span>
  sum <span style="color: #707183;">[</span>distancia <span style="color: #7388d6;">(</span>t<span style="color: #a0522d;">!</span>i<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">(</span>final8P<span style="color: #a0522d;">!</span>i<span style="color: #7388d6;">)</span> <span style="color: #a0522d;">|</span> i <span style="color: #a0522d;">&lt;-</span> <span style="color: #7388d6;">[</span>0<span style="color: #a0522d;">..</span>8<span style="color: #7388d6;">]</span><span style="color: #707183;">]</span>
</pre>
</div></li>

<li><p>
Dos estados se consideran iguales si tienen la misma heurística.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">instance</span> <span style="color: #228b22;">Eq</span> <span style="color: #228b22;">Tableros</span>
  <span style="color: #a020f0;">where</span> <span style="color: #228b22;">Est</span><span style="color: #707183;">(</span>t1<span style="color: #228b22;">:</span><span style="color: #a020f0;">_</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">==</span> <span style="color: #228b22;">Est</span><span style="color: #707183;">(</span>t2<span style="color: #228b22;">:</span><span style="color: #a020f0;">_</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> heur1 t1 <span style="color: #a0522d;">==</span> heur1 t2
</pre>
</div></li>

<li><p>
Un estado es menor o igual que otro si tiene una heurística menor o igual.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">instance</span> <span style="color: #228b22;">Ord</span> <span style="color: #228b22;">Tableros</span> <span style="color: #a020f0;">where</span>
  <span style="color: #228b22;">Est</span> <span style="color: #707183;">(</span>t1<span style="color: #228b22;">:</span><span style="color: #a020f0;">_</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">&lt;=</span> <span style="color: #228b22;">Est</span> <span style="color: #707183;">(</span>t2<span style="color: #228b22;">:</span><span style="color: #a020f0;">_</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> heur1 t1 <span style="color: #a0522d;">&lt;=</span> heur1 t2
</pre>
</div></li>

<li><p>
<code>(buscaPM_8P)</code> es la lista de las soluciones del 8 puzzle por búsqueda
primero el mejor.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">buscaPM_8P</span> <span style="color: #a0522d;">=</span> buscaPM sucesores8P
                     esFinal8P
                     <span style="color: #707183;">(</span><span style="color: #228b22;">Est</span> <span style="color: #7388d6;">[</span>inicial8P<span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org36af926" class="outline-2">
<h2 id="org36af926"><span class="section-number-2">4.</span> Búsqueda en escalada</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orga5b0311" class="outline-3">
<h3 id="orga5b0311"><span class="section-number-3">4.1.</span> El patrón de búsqueda en escalada</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li><p>
<code>(buscaEscalada s o e)</code> es la lista de soluciones del problema de espacio de
estado definido por la función sucesores (<code>s</code>), el objetivo (<code>o</code>) y estado
inicial (<code>e</code>), obtenidas buscando por escalada.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">module</span> <span style="color: #228b22;">BusquedaEnEscalada</span> <span style="color: #707183;">(</span>buscaEscalada<span style="color: #707183;">)</span> <span style="color: #a020f0;">where</span>

<span style="color: #0000ff;">buscaEscalada</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Ord</span> nodo <span style="color: #a0522d;">=&gt;</span> <span style="color: #707183;">(</span>nodo <span style="color: #a0522d;">-&gt;</span> <span style="color: #7388d6;">[</span>nodo<span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>
                 <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">(</span>nodo <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">-&gt;</span> nodo <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>nodo<span style="color: #707183;">]</span>
<span style="color: #0000ff;">buscaEscalada</span> sucesores esFinal x <span style="color: #a0522d;">=</span> busca' <span style="color: #707183;">(</span>inserta x vacia<span style="color: #707183;">)</span>
  <span style="color: #a020f0;">where</span>
    busca' c
      <span style="color: #a0522d;">|</span> esVacia c           <span style="color: #a0522d;">=</span> <span style="color: #707183;">[]</span>
      <span style="color: #a0522d;">|</span> esFinal <span style="color: #707183;">(</span>primero c<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">[</span>primero c<span style="color: #707183;">]</span>
      <span style="color: #a0522d;">|</span> otherwise           <span style="color: #a0522d;">=</span> busca' <span style="color: #707183;">(</span>foldr inserta vacia <span style="color: #7388d6;">(</span>sucesores x<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
      <span style="color: #a020f0;">where</span> x <span style="color: #a0522d;">=</span> primero c
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org9977d47" class="outline-3">
<h3 id="org9977d47"><span class="section-number-3">4.2.</span> El problema del cambio de monedas por escalada</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>El problema del cambio de monedas consiste en determinar cómo conseguir una
cantidad usando el menor número de monedas disponibles.</li>

<li><p>
Se resolverá por búsqueda en escalada.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">import</span> <span style="color: #228b22;">I1M.BusquedaEnEscalada</span>
</pre>
</div></li>

<li><p>
Las monedas son números enteros.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">Moneda</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Int</span>
</pre>
</div></li>

<li><p>
<code>monedas</code> es la lista del tipo de monedas disponibles. Se supone que hay un
número infinito de monedas de cada tipo.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">monedas</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Moneda</span><span style="color: #707183;">]</span>
<span style="color: #0000ff;">monedas</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">[</span>1,2,5,10,20,50,100<span style="color: #707183;">]</span>
</pre>
</div></li>

<li><p>
Las soluciones son listas de monedas.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">Soluciones</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Moneda</span><span style="color: #707183;">]</span>
</pre>
</div></li>

<li><p>
Los estados son pares formados por la cantidad que falta y la lista de
monedas usadas.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">NodoMonedas</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Int</span>, <span style="color: #7388d6;">[</span><span style="color: #228b22;">Moneda</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
<code>(sucesoresMonedas e)</code> es la lista de los sucesores del estado <code>e</code> en el
problema de las monedas. Por ejemplo,
</p>
<pre class="example">
λ&gt; sucesoresMonedas (199,[])
[(198,[1]),(197,[2]),(194,[5]),(189,[10]),
 (179,[20]),(149,[50]),(99,[100])]
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">sucesoresMonedas</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">NodoMonedas</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span><span style="color: #228b22;">NodoMonedas</span><span style="color: #707183;">]</span>
<span style="color: #0000ff;">sucesoresMonedas</span> <span style="color: #707183;">(</span>r,p<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span>
  <span style="color: #707183;">[</span><span style="color: #7388d6;">(</span>r<span style="color: #a0522d;">-</span>c,c<span style="color: #228b22;">:</span>p<span style="color: #7388d6;">)</span> <span style="color: #a0522d;">|</span> c <span style="color: #a0522d;">&lt;-</span> monedas, r<span style="color: #a0522d;">-</span>c <span style="color: #a0522d;">&gt;=</span> 0<span style="color: #707183;">]</span>
</pre>
</div></li>

<li><p>
<code>(esFinalMonedas e)</code> se verifica si <code>e</code> es un estado final del problema de
las monedas.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">esFinalMonedas</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">NodoMonedas</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
<span style="color: #0000ff;">esFinalMonedas</span> <span style="color: #707183;">(</span>v,<span style="color: #a020f0;">_</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> v<span style="color: #a0522d;">==</span>0
</pre>
</div></li>

<li><p>
<code>(cambio n)</code> es la solución del problema de las monedas por búsqueda en
escalada. Por ejemplo,
</p>
<pre class="example">
cambio 199  ==  [2,2,5,20,20,50,100]
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">cambio</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Int</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Soluciones</span>
<span style="color: #0000ff;">cambio</span> n <span style="color: #a0522d;">=</span>
  snd <span style="color: #707183;">(</span>head <span style="color: #7388d6;">(</span>buscaEscalada sucesoresMonedas
                           esFinalMonedas
                           <span style="color: #909183;">(</span>n,<span style="color: #709870;">[]</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org048208d" class="outline-3">
<h3 id="org048208d"><span class="section-number-3">4.3.</span> El algoritmo de Prim del árbol de expansión mínimo por escalada</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li><p>
Se resolverá mediante búsqueda en escalada.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">import</span> <span style="color: #228b22;">I1M.BusquedaEnEscalada</span>
<span style="color: #a020f0;">import</span> <span style="color: #228b22;">I1M.Grafo</span>
<span style="color: #a020f0;">import</span> <span style="color: #228b22;">Data.Array</span>
<span style="color: #a020f0;">import</span> <span style="color: #228b22;">Data.List</span>
</pre>
</div></li>

<li><p>
Ejemplo de grafo.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">g1</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Grafo</span> <span style="color: #228b22;">Int</span> <span style="color: #228b22;">Int</span>
<span style="color: #0000ff;">g1</span> <span style="color: #a0522d;">=</span> creaGrafo <span style="color: #228b22;">D</span> <span style="color: #707183;">(</span>1,5<span style="color: #707183;">)</span> <span style="color: #707183;">[</span><span style="color: #7388d6;">(</span>1,2,12<span style="color: #7388d6;">)</span>,<span style="color: #7388d6;">(</span>1,3,34<span style="color: #7388d6;">)</span>,<span style="color: #7388d6;">(</span>1,5,78<span style="color: #7388d6;">)</span>,
                        <span style="color: #7388d6;">(</span>2,4,55<span style="color: #7388d6;">)</span>,<span style="color: #7388d6;">(</span>2,5,32<span style="color: #7388d6;">)</span>,
                        <span style="color: #7388d6;">(</span>3,4,61<span style="color: #7388d6;">)</span>,<span style="color: #7388d6;">(</span>3,5,44<span style="color: #7388d6;">)</span>,
                        <span style="color: #7388d6;">(</span>4,5,93<span style="color: #7388d6;">)</span><span style="color: #707183;">]</span>
</pre>
</div></li>

<li><p>
Una arista esta formada dos nodos junto con su peso.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">Arista</span> a b <span style="color: #a0522d;">=</span> <span style="color: #707183;">(</span>a,a,b<span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
Un nodo <code>(NodoAEM (p,t,r,aem))</code> está formado por
</p>
<ul class="org-ul">
<li>el peso <code>p</code> de la última arista añadida el árbol de expansión mínimo
(<code>aem</code>),</li>
<li>la lista <code>t</code> de nodos del grafo que están en el <code>aem</code>,</li>
<li>la lista <code>r</code> de nodos del grafo que no están en el <code>aem</code> y</li>
<li>el <code>aem</code>.</li>
</ul>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">type</span> <span style="color: #228b22;">NodoAEM</span> a b <span style="color: #a0522d;">=</span> <span style="color: #707183;">(</span>b,<span style="color: #7388d6;">[</span>a<span style="color: #7388d6;">]</span>,<span style="color: #7388d6;">[</span>a<span style="color: #7388d6;">]</span>,<span style="color: #7388d6;">[</span><span style="color: #228b22;">Arista</span> a b<span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
<code>(sucesoresAEM g n)</code> es la lista de los sucesores del nodo <code>n</code> en el grafo
<code>g</code>. Por ejemplo,
</p>
<pre class="example">
λ&gt; sucesoresAEM g1 (0,[1],[2..5],[])
[(12,[2,1],[3,4,5],[(1,2,12)]),
 (34,[3,1],[2,4,5],[(1,3,34)]),
 (78,[5,1],[2,3,4],[(1,5,78)])]
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">sucesoresAEM</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Ix</span> a,<span style="color: #228b22;">Num</span> b<span style="color: #707183;">)</span> <span style="color: #a0522d;">=&gt;</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Grafo</span> a b<span style="color: #707183;">)</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">(</span><span style="color: #228b22;">NodoAEM</span> a b<span style="color: #707183;">)</span>
                           <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">NodoAEM</span> a b<span style="color: #7388d6;">)</span><span style="color: #707183;">]</span>
<span style="color: #0000ff;">sucesoresAEM</span> g <span style="color: #707183;">(</span><span style="color: #a020f0;">_</span>,t,r,aem<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span>
  <span style="color: #707183;">[</span><span style="color: #7388d6;">(</span>peso x y g, <span style="color: #909183;">(</span>y<span style="color: #228b22;">:</span>t<span style="color: #909183;">)</span>, delete y r, <span style="color: #909183;">(</span>x,y,peso x y g<span style="color: #909183;">)</span><span style="color: #228b22;">:</span>aem<span style="color: #7388d6;">)</span>
   <span style="color: #a0522d;">|</span> x <span style="color: #a0522d;">&lt;-</span> t , y <span style="color: #a0522d;">&lt;-</span> r, aristaEn g <span style="color: #7388d6;">(</span>x,y<span style="color: #7388d6;">)</span><span style="color: #707183;">]</span>
</pre>
</div></li>

<li><p>
<code>(esFinalAEM n)</code> se verifica si <code>n</code> es un estado final; es decir, si no queda
ningún elemento en la lista de nodos sin colocar en el árbol de expansión
mínimo.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">esFinalAEM</span> <span style="color: #707183;">(</span><span style="color: #a020f0;">_</span>,<span style="color: #a020f0;">_</span>,<span style="color: #7388d6;">[]</span>,<span style="color: #a020f0;">_</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">True</span>
<span style="color: #0000ff;">esFinalAEM</span> <span style="color: #a020f0;">_</span>          <span style="color: #a0522d;">=</span> <span style="color: #228b22;">False</span>
</pre>
</div></li>

<li><p>
<code>(prim g)</code> es el árbol de expansión mínimo del grafo <code>g</code>, por el algoritmo de
Prim como búsqueda en escalada. Por ejemplo,
</p>
<pre class="example">
prim g1 == [(2,4,55),(1,3,34),(2,5,32),(1,2,12)]
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">prim</span> g <span style="color: #a0522d;">=</span> sol
  <span style="color: #a020f0;">where</span> <span style="color: #707183;">[</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">_</span>,<span style="color: #a020f0;">_</span>,<span style="color: #a020f0;">_</span>,sol<span style="color: #7388d6;">)</span><span style="color: #707183;">]</span> <span style="color: #a0522d;">=</span> buscaEscalada <span style="color: #707183;">(</span>sucesoresAEM g<span style="color: #707183;">)</span>
                                      esFinalAEM
                                      <span style="color: #707183;">(</span>0,<span style="color: #7388d6;">[</span>n<span style="color: #7388d6;">]</span>,ns,<span style="color: #7388d6;">[]</span><span style="color: #707183;">)</span>
        <span style="color: #707183;">(</span>n<span style="color: #228b22;">:</span>ns<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> nodos g
</pre>
</div></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org369276f" class="outline-2">
<h2 id="org369276f"><span class="section-number-2">5.</span> Material complementario</h2>
<div class="outline-text-2" id="text-5">
<p>
El código del tema se encuentra en los siguientes enlaces
</p>
<ul class="org-ul">
<li>Divide y vencerás
<ul class="org-ul">
<li><a href="https://github.com/jaalonso/I1M-Cod-Temas/blob/master/src/Tema_23/DivideVenceras.hs">El patrón divide y vencerás</a>.</li>
<li><a href="https://github.com/jaalonso/I1M-Cod-Temas/blob/master/src/Tema_23/DivideVencerasOrdMezcla.hs">Ordenación por mezcla</a>.</li>
<li><a href="https://github.com/jaalonso/I1M-Cod-Temas/blob/master/src/Tema_23/DivideVencerasOrdRapida.hs">Ordenación rápida</a>.</li>
</ul></li>
<li>Búsqueda en espacios de estados:
<ul class="org-ul">
<li><a href="https://github.com/jaalonso/I1M-Cod-Temas/blob/master/src/Tema_23/BusquedaEnEspaciosDeEstados.hs">El patrón de búsqueda en espacios de estados</a>.</li>
<li><a href="https://github.com/jaalonso/I1M-Cod-Temas/blob/master/src/Tema_23/BEE_Reinas.hs">El problema de las n reinas</a>.</li>
<li><a href="https://github.com/jaalonso/I1M-Cod-Temas/blob/master/src/Tema_23/BEE_Mochila.hs">El problema de la mochila</a>.</li>
</ul></li>
<li>Búsqueda por primero el mejor:
<ul class="org-ul">
<li><a href="https://github.com/jaalonso/I1M-Cod-Temas/blob/master/src/Tema_23/BusquedaPrimeroElMejor.hs">El patrón de búsqueda por primero el mejor</a>.</li>
<li><a href="https://github.com/jaalonso/I1M-Cod-Temas/blob/master/src/Tema_23/BPM_8Puzzle.hs">El 8 puzzle</a>.</li>
</ul></li>
<li>Búsqueda en escalada:
<ul class="org-ul">
<li><a href="https://github.com/jaalonso/I1M-Cod-Temas/blob/master/src/Tema_23/BusquedaEnEscalada.hs">El patrón de búsqueda en escalada</a>.</li>
<li><a href="https://github.com/jaalonso/I1M-Cod-Temas/blob/master/src/Tema_23/Escalada_Monedas.hs">El problema del cambio de monedas</a>.</li>
<li><a href="https://github.com/jaalonso/I1M-Cod-Temas/blob/master/src/Tema_23/Escalada_Prim.hs">El algoritmo de Prim del árbol de expansión mínimo</a>.</li>
</ul></li>
</ul>

<p>
Este tema también se encuentra en los siguientes formatos:
</p>
<ul class="org-ul">
<li>Como <a href="./tema-23.pdf">transparencias en PDF</a>.</li>
<li>Como <a href="https://mybinder.org/v2/gh/jaalonso/Temas_interactivos_de_PF_con_Haskell/master?urlpath=lab/tree/temas/Tema-23.ipynb">libro interactivo en IHaskell sobre Jupyter</a>.</li>
<li>Como vídeos de clase: <a href="https://youtu.be/ohdkfDxFPH0">vídeo 1</a>, <a href="https://youtu.be/WJ_QA0H82Xo">vídeo 2</a>, <a href="https://youtu.be/T02kejM1AqE">vídeo 3</a>, <a href="https://youtu.be/B9RRXZ4HNm4">vídeo 4</a>, <a href="https://youtu.be/-NqS03QuAzs">vídeo 5</a>, <a href="https://youtu.be/gCcQf3rNcRw">vídeo 6</a> y
<a href="https://youtu.be/OidcM24zBeg">vídeo 7</a>.</li>
</ul>
</div>
</div>

<div id="outline-container-org375d8a5" class="outline-2">
<h2 id="org375d8a5"><span class="section-number-2">6.</span> Bibliografía</h2>
<div class="outline-text-2" id="text-6">
<ul class="org-ul">
<li>F. Rabhi y G. Lapalme. <a href="https://www.iro.umontreal.ca/~lapalme/Algorithms-functional.html">Algorithms: A functional programming approach</a>.
<ul class="org-ul">
<li>Cap. 8: Top-down design techniques.</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<hr>
<center>
<p><a href="/"><i class="fa fa-home"></i></a> |
   <a href="/cursos/i1m/">Inicial</a> |
   <a href="/cursos/i1m/temas.html">Temas  </a>
</p>
</center>
<div id="extras">
  <p><a href="/">José A. Alonso Jiménez</a>
  <p>Sevilla, 10 de junio del 2021</p>
  <p><i class="fa fa-cc"></i> Licencia: <a href="https://creativecommons.org/licenses/by-nc-sa/2.5/es/">Creative Commons</a>.</p>
</div>
</div>
</body>
</html>
