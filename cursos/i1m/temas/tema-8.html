<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es">
<head>
<!-- 25 de abril del 2021 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tema 8: Razonamiento sobre programas</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="José A. Alonso" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../../../css/estilo-org.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<p><a href="/cursos/i1m/">Inicial</a> |
   <a href="/cursos/i1m/temas.html">Temas  </a>
</p>
</div>
<div id="content">
<h1 class="title">Tema 8: Razonamiento sobre programas</h1>
<div id="table-of-contents">
<h2>&Iacute;ndice</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org9c9b6e6">1. Razonamiento ecuacional</a>
<ul>
<li><a href="#orgb8e62d9">1.1. Cálculo con longitud</a></li>
<li><a href="#org58e0c5c">1.2. Propiedad de intercambia</a></li>
<li><a href="#org0a29dcd">1.3. Inversa de listas unitarias</a></li>
<li><a href="#orgff21521">1.4. Razonamiento ecuacional con análisis de casos</a></li>
</ul>
</li>
<li><a href="#org2c3d6eb">2. Razonamiento por inducción sobre los naturales</a>
<ul>
<li><a href="#org5a2ffa7">2.1. Esquema de inducción sobre los naturales</a></li>
<li><a href="#orga84ccd4">2.2. Ejemplo de inducción sobre los naturales</a></li>
</ul>
</li>
<li><a href="#org8affd2e">3. Razonamiento por inducción sobre listas</a>
<ul>
<li><a href="#orgf5af1e7">3.1. Esquema de inducción sobre listas</a></li>
<li><a href="#org6c701b8">3.2. Asociatividad de <code>++</code></a></li>
<li><a href="#org6034572">3.3. [] es la identidad para ++ por la derecha</a></li>
<li><a href="#orgc0bfdbb">3.4. Relación entre <code>length</code> y <code>++</code></a></li>
<li><a href="#org5cdb921">3.5. Relación entre <code>take</code> y <code>drop</code></a></li>
</ul>
</li>
<li><a href="#org711f5f1">4. Equivalencia de funciones</a></li>
<li><a href="#org831c863">5. Propiedades de funciones de orden superior</a>
<ul>
<li><a href="#org68887ae">5.1. Relación entre <code>sum</code> y <code>map</code></a></li>
<li><a href="#orga8db848">5.2. Comprobación de propiedades con argumentos funcionales</a></li>
</ul>
</li>
<li><a href="#org835b3dd">6. Bibliografía</a></li>
</ul>
</div>
</div>

<div id="outline-container-org9c9b6e6" class="outline-2">
<h2 id="org9c9b6e6"><span class="section-number-2">1</span> Razonamiento ecuacional</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgb8e62d9" class="outline-3">
<h3 id="orgb8e62d9"><span class="section-number-3">1.1</span> Cálculo con longitud</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li><p>
Definición de <code>longitud</code>
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">longitud</span> <span style="color: #707183;">[]</span>     <span style="color: #a0522d;">=</span> 0                 <span style="color: #b22222;">-- </span><span style="color: #b22222;">longitud.1</span>
<span style="color: #0000ff;">longitud</span> <span style="color: #707183;">(</span><span style="color: #a020f0;">_</span><span style="color: #228b22;">:</span>xs<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> 1 <span style="color: #a0522d;">+</span> longitud xs   <span style="color: #b22222;">-- </span><span style="color: #b22222;">longitud.2</span>
</pre>
</div></li>

<li>Propiedad: <code>longitud [2,3,1] = 3</code></li>

<li><p>
Demostración:
</p>
<pre class="example">
longitud [2,3,1]
= 1 + longitud [2,3]          [por longitud.2]
= 1 + (1 + longitud [3])      [por longitud.2]
= 1 + (1 + (1 + longitud [])) [por longitud.2]
= 1 + (1 + (1 + 0)            [por longitud.1]
= 3
</pre></li>
</ul>
</div>
</div>

<div id="outline-container-org58e0c5c" class="outline-3">
<h3 id="org58e0c5c"><span class="section-number-3">1.2</span> Propiedad de intercambia</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li><p>
Definición de <code>intercambia</code>:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">intercambia</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">(</span>a,b<span style="color: #707183;">)</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">(</span>b,a<span style="color: #707183;">)</span>
<span style="color: #0000ff;">intercambia</span> <span style="color: #707183;">(</span>x,y<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">(</span>y,x<span style="color: #707183;">)</span>       <span style="color: #b22222;">-- </span><span style="color: #b22222;">intercambia</span>
</pre>
</div></li>

<li>Propiedad: <code>intercambia (intercambia (x,y)) = (x,y)</code></li>

<li><p>
Demostración:
</p>
<pre class="example">
intercambia (intercambia (x,y))
= intercambia (y,x)      [por intercambia]
= (x,y)                  [por intercambia]
</pre></li>

<li><p>
Propiedad en QuickCheck:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">prop_intercambia</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Eq</span> a <span style="color: #a0522d;">=&gt;</span> a <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
<span style="color: #0000ff;">prop_intercambia</span> x y <span style="color: #a0522d;">=</span> intercambia <span style="color: #707183;">(</span>intercambia <span style="color: #7388d6;">(</span>x,y<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">==</span> <span style="color: #707183;">(</span>x,y<span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
Comprobación:
</p>
<pre class="example">
λ&gt; quickCheck prop_intercambia
+++ OK, passed 100 tests.
</pre></li>

<li><p>
Nota: Para usar la librería QuickCheck hay que importarla escribiendo al
principio del fichero
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">import</span> <span style="color: #228b22;">Test.QuickCheck</span>
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org0a29dcd" class="outline-3">
<h3 id="org0a29dcd"><span class="section-number-3">1.3</span> Inversa de listas unitarias</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li><p>
Inversa de una lista:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">inversa</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span>
<span style="color: #0000ff;">inversa</span> <span style="color: #707183;">[]</span>     <span style="color: #a0522d;">=</span> <span style="color: #707183;">[]</span>                  <span style="color: #b22222;">-- </span><span style="color: #b22222;">inversa.1</span>
<span style="color: #0000ff;">inversa</span> <span style="color: #707183;">(</span>x<span style="color: #228b22;">:</span>xs<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> inversa xs <span style="color: #a0522d;">++</span> <span style="color: #707183;">[</span>x<span style="color: #707183;">]</span>   <span style="color: #b22222;">-- </span><span style="color: #b22222;">inversa.2</span>
</pre>
</div></li>

<li><p>
Propiedad: <code>inversa [x] = [x]</code>
</p>
<pre class="example">
inversa [x]
= inversa (x:[])      [notación de lista]
= (inversa []) ++ [x] [inversa.2]
= [] ++ [x]           [inversa.1]
= [x]                 [def. de ++]
</pre></li>

<li><p>
Propiedad en QuickCheck:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">prop_inversa_unitaria</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Eq</span> a <span style="color: #a0522d;">=&gt;</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
<span style="color: #0000ff;">prop_inversa_unitaria</span> x <span style="color: #a0522d;">=</span> inversa <span style="color: #707183;">[</span>x<span style="color: #707183;">]</span> <span style="color: #a0522d;">==</span> <span style="color: #707183;">[</span>x<span style="color: #707183;">]</span>
</pre>
</div></li>

<li><p>
Comprobación:
</p>
<pre class="example">
λ&gt; quickCheck prop_inversa_unitaria
+++ OK, passed 100 tests.
</pre></li>
</ul>
</div>
</div>

<div id="outline-container-orgff21521" class="outline-3">
<h3 id="orgff21521"><span class="section-number-3">1.4</span> Razonamiento ecuacional con análisis de casos</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-org475e0d8" class="outline-4">
<h4 id="org475e0d8"><span class="section-number-4">1.4.1</span> Casos sobre booleanos</h4>
<div class="outline-text-4" id="text-1-4-1">
<ul class="org-ul">
<li><p>
Negación lógica:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">not</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Bool</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
<span style="color: #0000ff;">not</span> <span style="color: #228b22;">False</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">True</span>
<span style="color: #0000ff;">not</span> <span style="color: #228b22;">True</span>  <span style="color: #a0522d;">=</span> <span style="color: #228b22;">False</span>
</pre>
</div></li>

<li>Prop.: <code>not (not x) = x</code></li>

<li>Demostración por casos:
<ul class="org-ul">
<li><p>
Caso 1: <code>x = True</code>:
</p>
<pre class="example">
not (not True)
= not False      [not.2]
= True           [not.1]
</pre></li>
<li><p>
Caso 2: <code>x = False</code>:
</p>
<pre class="example">
not (not False)
= not True      [not.1]
= False         [not.2]
</pre></li>
</ul></li>

<li><p>
Propiedad con QuickCheck:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">prop_doble_negacion</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Bool</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
<span style="color: #0000ff;">prop_doble_negacion</span> x <span style="color: #a0522d;">=</span> not <span style="color: #707183;">(</span>not x<span style="color: #707183;">)</span> <span style="color: #a0522d;">==</span> x
</pre>
</div></li>

<li><p>
Comprobación:
</p>
<pre class="example">
λ&gt; quickCheck prop_doble_negacion
+++ OK, passed 100 tests.
</pre></li>
</ul>
</div>
</div>

<div id="outline-container-org5be63a5" class="outline-4">
<h4 id="org5be63a5"><span class="section-number-4">1.4.2</span> Casos sobre listas</h4>
<div class="outline-text-4" id="text-1-4-2">
<ul class="org-ul">
<li><p>
Definiciones de <code>null</code> y <code>(++)</code>:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">null</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
<span style="color: #0000ff;">null</span> <span style="color: #707183;">[]</span>           <span style="color: #a0522d;">=</span> <span style="color: #228b22;">True</span>            <span style="color: #b22222;">-- </span><span style="color: #b22222;">null.1</span>
<span style="color: #0000ff;">null</span> <span style="color: #707183;">(</span><span style="color: #a020f0;">_</span><span style="color: #228b22;">:</span><span style="color: #a020f0;">_</span><span style="color: #707183;">)</span>        <span style="color: #a0522d;">=</span> <span style="color: #228b22;">False</span>           <span style="color: #b22222;">-- </span><span style="color: #b22222;">null.2</span>

<span style="color: #707183;">(</span><span style="color: #0000ff;">++</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span>
<span style="color: #707183;">[]</span>     <span style="color: #a0522d;">++</span> ys      <span style="color: #a0522d;">=</span> ys              <span style="color: #b22222;">-- </span><span style="color: #b22222;">(++).1</span>
<span style="color: #707183;">(</span>x<span style="color: #228b22;">:</span>xs<span style="color: #707183;">)</span> <span style="color: #a0522d;">++</span> ys      <span style="color: #a0522d;">=</span> x <span style="color: #228b22;">:</span> <span style="color: #707183;">(</span>xs <span style="color: #a0522d;">++</span> ys<span style="color: #707183;">)</span>  <span style="color: #b22222;">-- </span><span style="color: #b22222;">(++).2</span>
</pre>
</div></li>

<li>Propiedad: <code>null xs = null (xs ++ xs)</code>.</li>

<li>Demostración por casos según <code>xs</code>:
<ul class="org-ul">
<li><p>
Caso 1: <code>xs = []</code>:
</p>
<pre class="example">
null xs
= null []          [por hipótesis]
= null ([] ++ [])  [por (++).1]
= null (xs ++ xs)  [por hipótesis]
</pre></li>
<li><p>
Caso <code>xs = y:ys</code>: Reduciendo ambos lados:
</p>
<pre class="example">
null xs
= null (y:ys)              [por hipótesis]
= False                    [por null.2
= null (y:(ys ++ (y:ys))   [por null.2]
= null ((y:ys) ++ (y:ys))  [por (++).2]
= null (xs ++ xs)          [por hipótesis]
</pre></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org2c3d6eb" class="outline-2">
<h2 id="org2c3d6eb"><span class="section-number-2">2</span> Razonamiento por inducción sobre los naturales</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org5a2ffa7" class="outline-3">
<h3 id="org5a2ffa7"><span class="section-number-3">2.1</span> Esquema de inducción sobre los naturales</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Para demostrar que todos los números naturales tienen una propiedad <code>P</code>
basta probar:
</p>
<ul class="org-ul">
<li>Caso base <code>n=0</code>: <code>P(0)</code>.</li>
<li>Caso inductivo <code>n=(m+1)</code>: Suponiendo <code>P(m)</code> demostrar <code>P(m+1)</code>.</li>
</ul>

<p>
En el caso inductivo, la propiedad <code>P(n)</code> se llama la hipótesis de inducción.
</p>
</div>
</div>

<div id="outline-container-orga84ccd4" class="outline-3">
<h3 id="orga84ccd4"><span class="section-number-3">2.2</span> Ejemplo de inducción sobre los naturales</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li><p>
<code>(replicate n x)</code> es la lista formda por <code>n</code> elementos iguales a <code>x</code>. Por
ejemplo,
</p>
<pre class="example">
replicate 3 5  ==  [5,5,5]
</pre>

<p>
Su definición es
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">replicate</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Int</span> <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span>
<span style="color: #0000ff;">replicate</span> 0 <span style="color: #a020f0;">_</span> <span style="color: #a0522d;">=</span> <span style="color: #707183;">[]</span>
<span style="color: #0000ff;">replicate</span> n x <span style="color: #a0522d;">=</span> x <span style="color: #228b22;">:</span> replicate <span style="color: #707183;">(</span>n<span style="color: #a0522d;">-</span>1<span style="color: #707183;">)</span> x
</pre>
</div></li>

<li>Prop.: <code>length (replicate n x) = n</code></li>

<li>Demostración por inducción en <code>n</code>:
<ul class="org-ul">
<li><p>
Caso base (<code>n=0</code>):
</p>
<pre class="example">
length (replicate 0 x)
= length []            [por replicate.1]
= 0                    [por def. length]
</pre></li>
<li><p>
Caso inductivo (<code>n=m+1</code>):
</p>
<pre class="example">
length (replicate (m+1) x)
= length (x:(replicate m x))  [por replicate.2]
= 1 + length (replicate m x)  [por def. length]
= 1 + m                       [por hip. ind.]
= m + 1                       [por conmutativa de +]
</pre></li>
</ul></li>

<li><p>
Propiedad en QuickCheck:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">prop_length_replicate</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Int</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Int</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
<span style="color: #0000ff;">prop_length_replicate</span> n xs <span style="color: #a0522d;">=</span>
  length <span style="color: #707183;">(</span>replicate m xs<span style="color: #707183;">)</span> <span style="color: #a0522d;">==</span> m
  <span style="color: #a020f0;">where</span> m <span style="color: #a0522d;">=</span> abs n
</pre>
</div></li>

<li><p>
Comprobación de la propiedad:
</p>
<pre class="example">
λ&gt; quickCheck prop_length_replicate
OK, passed 100 tests.
</pre></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org8affd2e" class="outline-2">
<h2 id="org8affd2e"><span class="section-number-2">3</span> Razonamiento por inducción sobre listas</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgf5af1e7" class="outline-3">
<h3 id="orgf5af1e7"><span class="section-number-3">3.1</span> Esquema de inducción sobre listas</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Para demostrar que todas las listas finitas tienen una propiedad <code>P</code> basta
probar:
</p>
<ul class="org-ul">
<li>Caso base <code>xs=[]</code>: <code>P([])</code>.</li>
<li>Caso inductivo <code>xs=(y:ys)</code>: Suponiendo <code>P(ys)</code> demostrar <code>P(y:ys)</code>.</li>
</ul>

<p>
En el caso inductivo, la propiedad <code>P(ys)</code> se llama la hipótesis de inducción.
</p>
</div>
</div>

<div id="outline-container-org6c701b8" class="outline-3">
<h3 id="org6c701b8"><span class="section-number-3">3.2</span> Asociatividad de <code>++</code></h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li><p>
Definición de <code>++</code>:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #707183;">(</span><span style="color: #0000ff;">++</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span>
<span style="color: #707183;">[]</span>     <span style="color: #a0522d;">++</span> ys <span style="color: #a0522d;">=</span> ys             <span style="color: #b22222;">-- </span><span style="color: #b22222;">++.1</span>
<span style="color: #707183;">(</span>x<span style="color: #228b22;">:</span>xs<span style="color: #707183;">)</span> <span style="color: #a0522d;">++</span> ys <span style="color: #a0522d;">=</span> x <span style="color: #228b22;">:</span> <span style="color: #707183;">(</span>xs <span style="color: #a0522d;">++</span> ys<span style="color: #707183;">)</span> <span style="color: #b22222;">-- </span><span style="color: #b22222;">++.2</span>
</pre>
</div></li>

<li><p>
Propiedad:
</p>
<pre class="example">
xs ++ (ys ++ zs)=(xs ++ ys) ++ zs
</pre></li>

<li><p>
Propiedad con QuickCheck:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">prop_asociativa_conc</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Int</span><span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Int</span><span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Int</span><span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
<span style="color: #0000ff;">prop_asociativa_conc</span> xs ys zs <span style="color: #a0522d;">=</span>
    xs <span style="color: #a0522d;">++</span> <span style="color: #707183;">(</span>ys <span style="color: #a0522d;">++</span> zs<span style="color: #707183;">)</span><span style="color: #a0522d;">==</span><span style="color: #707183;">(</span>xs <span style="color: #a0522d;">++</span> ys<span style="color: #707183;">)</span> <span style="color: #a0522d;">++</span> zs
</pre>
</div></li>

<li><p>
Comprobación:
</p>
<pre class="example">
λ&gt; quickCheck prop_asociatividad_conc
OK, passed 100 tests.
</pre></li>

<li>Demostración por inducción en <code>xs</code>:
<ul class="org-ul">
<li><p>
Caso base <code>xs = []</code>:
</p>
<pre class="example">
xs ++ (ys ++ zs)
= [] ++ (ys ++ zs)   [por hipótesis]
= ys ++ zs           [por  ++ .1]
= ([] ++ ys) ++ zs   [por  ++ .1]
= (xs ++ ys) ++ zs   [por hipótesis]
</pre></li>
<li><p>
Caso inductivo <code>xs = a:as</code>: Suponiendo la hipótesis de inducción
</p>
<pre class="example">
as ++ (ys ++ zs) = (as ++ ys) ++ zs
</pre>

<p>
hay que demostrar que
</p>
<pre class="example">
(a:as) ++ (ys ++ zs) = ((a:as) ++ ys) ++ zs
</pre>

<p>
La demostración es
</p>
<pre class="example">
(a:as) ++ (ys ++ zs)
= a:(as ++ (ys ++ zs))  [por  ++ .2]
= a:((as ++ ys) ++ zs)  [por hip. ind.]
= (a:(as ++ ys)) ++ zs  [por ++.2]
= ((a:as) ++ ys) ++ zs  [por ++.2]
</pre></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org6034572" class="outline-3">
<h3 id="org6034572"><span class="section-number-3">3.3</span> [] es la identidad para ++ por la derecha</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>Propiedad: <code>xs ++ []=xs</code></li>

<li><p>
Propiedad con QuickCheck:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">prop_identidad_concatenacion</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Int</span><span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
<span style="color: #0000ff;">prop_identidad_concatenacion</span> xs <span style="color: #a0522d;">=</span> xs <span style="color: #a0522d;">++</span> <span style="color: #707183;">[]</span> <span style="color: #a0522d;">==</span> xs
</pre>
</div></li>

<li><p>
Comprobación:
</p>
<pre class="example">
λ&gt; quickCheck prop_identidad_concatenacion
OK, passed 100 tests.
</pre></li>

<li>Demostración por inducción en <code>xs</code>:
<ul class="org-ul">
<li><p>
Caso base <code>xs = []</code>:
</p>
<pre class="example">
xs ++ []
= [] ++ []
= []         [por ++.1]
</pre></li>
<li><p>
Caso inductivo <code>xs = a:as</code>: Suponiendo la hipótesis de inducción
</p>
<pre class="example">
as ++ [] = as
</pre>

<p>
hay que demostrar que
</p>
<pre class="example">
(a:as) ++ [] = (a:as)
</pre>

<p>
La demostración es
</p>
<pre class="example">
(a:as) ++ []
= a:(as ++ [])   [por ++.2]
= a:as           [por hip. ind.]
</pre></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgc0bfdbb" class="outline-3">
<h3 id="orgc0bfdbb"><span class="section-number-3">3.4</span> Relación entre <code>length</code> y <code>++</code></h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li><p>
Definiciones de <code>length</code> y <code>++</code>:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">length</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Int</span>
<span style="color: #0000ff;">length</span> <span style="color: #707183;">[]</span>     <span style="color: #a0522d;">=</span> 0                 <span style="color: #b22222;">-- </span><span style="color: #b22222;">length.1</span>
<span style="color: #0000ff;">length</span> <span style="color: #707183;">(</span>x<span style="color: #228b22;">:</span>xs<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> 1 <span style="color: #a0522d;">+</span> n_length xs   <span style="color: #b22222;">-- </span><span style="color: #b22222;">length.2</span>

<span style="color: #707183;">(</span><span style="color: #0000ff;">++</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span>
<span style="color: #707183;">[]</span>     <span style="color: #a0522d;">++</span> ys <span style="color: #a0522d;">=</span> ys                 <span style="color: #b22222;">-- </span><span style="color: #b22222;">++.1</span>
<span style="color: #707183;">(</span>x<span style="color: #228b22;">:</span>xs<span style="color: #707183;">)</span> <span style="color: #a0522d;">++</span> ys <span style="color: #a0522d;">=</span> x <span style="color: #228b22;">:</span> <span style="color: #707183;">(</span>xs <span style="color: #a0522d;">++</span> ys<span style="color: #707183;">)</span>     <span style="color: #b22222;">-- </span><span style="color: #b22222;">++.2</span>
</pre>
</div></li>

<li>Propiedad: <code>length(xs ++ ys) = (length xs)+(length ys)</code></li>

<li><p>
Propiedad con QuickCheck:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">prop_length_append</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Int</span><span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Int</span><span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
<span style="color: #0000ff;">prop_length_append</span> xs ys <span style="color: #a0522d;">=</span>
   length<span style="color: #707183;">(</span>xs <span style="color: #a0522d;">++</span> ys<span style="color: #707183;">)</span><span style="color: #a0522d;">==</span><span style="color: #707183;">(</span>length xs<span style="color: #707183;">)</span><span style="color: #a0522d;">+</span><span style="color: #707183;">(</span>length ys<span style="color: #707183;">)</span>
</pre>
</div></li>

<li><p>
Comprobación:
</p>
<pre class="example">
λ&gt; quickCheck prop_length_append
OK, passed 100 tests.
</pre></li>

<li>Demostración por inducción en <code>xs</code>:
<ul class="org-ul">
<li><p>
Caso base <code>xs = []</code>:
</p>
<pre class="example">
length([] ++ ys)
= length ys                [por ++.1]
= 0+(length ys)            [por aritmética]
= (length [])+(length ys)  [por length.1]
</pre></li>
<li><p>
Caso inductivo <code>xs = a:as</code>: Suponiendo la hipótesis de inducción
</p>
<pre class="example">
length(as ++ ys) = (length as)+(length ys)
</pre>

<p>
hay que demostrar que
</p>
<pre class="example">
length((a:as) ++ ys) = (length (a:as))+(length ys)
</pre>

<p>
La demostración es
</p>
<pre class="example">
length((a:as) ++ ys)
= length(a:(as ++ ys))              [por ++.2]
= 1 + length(as ++ ys)              [por length.2]
= 1 + ((length as) + (length ys))   [por hip. ind.]
= (1 + (length as)) + (length ys)   [por aritmética]
= (length (a:as)) + (length ys)     [por length.2]
</pre></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org5cdb921" class="outline-3">
<h3 id="org5cdb921"><span class="section-number-3">3.5</span> Relación entre <code>take</code> y <code>drop</code></h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li><p>
Definición de <code>take</code>, <code>drop</code> y <code>(++)</code>:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">take</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Int</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span>
<span style="color: #0000ff;">take</span> 0 <span style="color: #a020f0;">_</span>       <span style="color: #a0522d;">=</span> <span style="color: #707183;">[]</span>                  <span style="color: #b22222;">-- </span><span style="color: #b22222;">take.1</span>
<span style="color: #0000ff;">take</span> <span style="color: #a020f0;">_</span> <span style="color: #707183;">[]</span>      <span style="color: #a0522d;">=</span> <span style="color: #707183;">[]</span>                  <span style="color: #b22222;">-- </span><span style="color: #b22222;">take.2</span>
<span style="color: #0000ff;">take</span> n <span style="color: #707183;">(</span>x<span style="color: #228b22;">:</span>xs<span style="color: #707183;">)</span>  <span style="color: #a0522d;">=</span> x <span style="color: #228b22;">:</span> take <span style="color: #707183;">(</span>n<span style="color: #a0522d;">-</span>1<span style="color: #707183;">)</span> xs   <span style="color: #b22222;">-- </span><span style="color: #b22222;">take.3</span>

<span style="color: #0000ff;">drop</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Int</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span>
<span style="color: #0000ff;">drop</span> 0 xs      <span style="color: #a0522d;">=</span> xs                  <span style="color: #b22222;">-- </span><span style="color: #b22222;">drop.1</span>
<span style="color: #0000ff;">drop</span> <span style="color: #a020f0;">_</span> <span style="color: #707183;">[]</span>      <span style="color: #a0522d;">=</span> <span style="color: #707183;">[]</span>                  <span style="color: #b22222;">-- </span><span style="color: #b22222;">drop,2</span>
<span style="color: #0000ff;">drop</span> n <span style="color: #707183;">(</span><span style="color: #a020f0;">_</span><span style="color: #228b22;">:</span>xs<span style="color: #707183;">)</span>  <span style="color: #a0522d;">=</span> drop <span style="color: #707183;">(</span>n<span style="color: #a0522d;">-</span>1<span style="color: #707183;">)</span> xs       <span style="color: #b22222;">-- </span><span style="color: #b22222;">drop.3</span>

<span style="color: #707183;">(</span><span style="color: #0000ff;">++</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span>
<span style="color: #707183;">[]</span>     <span style="color: #a0522d;">++</span> ys <span style="color: #a0522d;">=</span> ys                    <span style="color: #b22222;">-- </span><span style="color: #b22222;">++.1</span>
<span style="color: #707183;">(</span>x<span style="color: #228b22;">:</span>xs<span style="color: #707183;">)</span> <span style="color: #a0522d;">++</span> ys <span style="color: #a0522d;">=</span> x <span style="color: #228b22;">:</span> <span style="color: #707183;">(</span>xs <span style="color: #a0522d;">++</span> ys<span style="color: #707183;">)</span>        <span style="color: #b22222;">-- </span><span style="color: #b22222;">++.2</span>
</pre>
</div></li>

<li>Propiedad: <code>take n xs ++ drop n xs = xs</code></li>

<li><p>
Propiedad con QuickCheck:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">prop_take_drop</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Int</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Int</span><span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Property</span>
<span style="color: #0000ff;">prop_take_drop</span> n xs <span style="color: #a0522d;">=</span>
  n <span style="color: #a0522d;">&gt;=</span> 0 <span style="color: #a0522d;">==&gt;</span> take n xs <span style="color: #a0522d;">++</span> drop n xs <span style="color: #a0522d;">==</span> xs
</pre>
</div></li>

<li><p>
Comprobación:
</p>
<pre class="example">
λ&gt; quickCheck prop_take_drop
OK, passed 100 tests.
</pre></li>

<li>Demostración por inducción en <code>n</code>:
<ul class="org-ul">
<li><p>
Caso base <code>n = 0</code>:
</p>
<pre class="example">
take 0 xs ++ drop 0 xs
= [] ++ xs              [por take.1 y drop.1]
= xs                    [por ++.1]
</pre></li>
</ul></li>

<li><p>
Caso inductivo <code>n = m+1</code>: Suponiendo la hipótesis de inducción 1
</p>
<pre class="example">
(∀ xs :: [a]) take m xs ++ drop m xs = xs
</pre>

<p>
hay que demostrar que
</p>
<pre class="example">
(∀ xs :: [a]) take (m+1) xs ++ drop (m+1) xs = xs
</pre>

<p>
Lo demostraremos por inducción en <code>xs</code>:
</p>
<ul class="org-ul">
<li><p>
Caso base <code>xs = []</code>:
</p>
<pre class="example">
take (m+1) [] ++ drop (m+1) []
= [] ++ []                        [por take.2 y drop.2]
= []                              [por ++.1]
</pre></li>
<li><p>
Caso inductivo <code>xs = a:as</code>: Suponiendo la hip. de inducción 2
</p>
<pre class="example">
take (m+1) as ++ drop (m+1) as = as
</pre>

<p>
hay que demostrar que
</p>
<pre class="example">
take (m+1) (a:as) ++ drop (m+1) (a:as) = (a:as)
</pre>

<p>
Demostración
</p>
<pre class="example">
take (m+1) (a:as) ++ drop (m+1) (a:as)
= (a:(take m as)) ++ (drop m as)     [take.3 y drop.3]
= (a:((take m as) ++ (drop m as))    [por ++.2]
= a:as                               [por hip. de ind. 1]
</pre></li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org711f5f1" class="outline-2">
<h2 id="org711f5f1"><span class="section-number-2">4</span> Equivalencia de funciones</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li><p>
Definiciones de <code>inversa1</code> e <code>inversa2</code>:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">inversa1, inversa2</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span>a<span style="color: #707183;">]</span>
<span style="color: #0000ff;">inversa1</span> <span style="color: #707183;">[]</span>     <span style="color: #a0522d;">=</span> <span style="color: #707183;">[]</span>                                    <span style="color: #b22222;">-- </span><span style="color: #b22222;">inversa1.1</span>
<span style="color: #0000ff;">inversa1</span> <span style="color: #707183;">(</span>x<span style="color: #228b22;">:</span>xs<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> inversa1 xs <span style="color: #a0522d;">++</span> <span style="color: #707183;">[</span>x<span style="color: #707183;">]</span>                    <span style="color: #b22222;">-- </span><span style="color: #b22222;">inversa1.2</span>

<span style="color: #0000ff;">inversa2</span> xs <span style="color: #a0522d;">=</span> inversa2Aux xs <span style="color: #707183;">[]</span>                         <span style="color: #b22222;">-- </span><span style="color: #b22222;">inversa2.1</span>
  <span style="color: #a020f0;">where</span> inversa2Aux <span style="color: #707183;">[]</span>     ys <span style="color: #a0522d;">=</span> ys                      <span style="color: #b22222;">-- </span><span style="color: #b22222;">inversa2Aux.1</span>
        inversa2Aux <span style="color: #707183;">(</span>x<span style="color: #228b22;">:</span>xs<span style="color: #707183;">)</span> ys <span style="color: #a0522d;">=</span> inversa2Aux xs <span style="color: #707183;">(</span>x<span style="color: #228b22;">:</span>ys<span style="color: #707183;">)</span>   <span style="color: #b22222;">-- </span><span style="color: #b22222;">inversa2Aux.2</span>
</pre>
</div></li>

<li>Propiedad: <code>inversa1 xs = inversa2 xs</code></li>

<li><p>
Propiedad con QuickCheck:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">prop_equiv_inversa</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Int</span><span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
<span style="color: #0000ff;">prop_equiv_inversa</span> xs <span style="color: #a0522d;">=</span> inversa1 xs <span style="color: #a0522d;">==</span> inversa2 xs
</pre>
</div></li>

<li><p>
Demostración: Es consecuencia del siguiente lema:
</p>
<pre class="example">
inversa1 xs ++ ys = inversa2Aux xs ys
</pre>

<p>
En efecto,
</p>
<pre class="example">
inversa1 xs
= inversa1 xs ++ []     [por identidad de ++]
= inversa2Aux xs ++ []  [por el lema]
= inversa2 xs           [por el inversa2.1]
</pre></li>

<li>Demostración del lema: Por inducción en <code>xs</code>:
<ul class="org-ul">
<li><p>
Caso base <code>xs = []</code>:
</p>
<pre class="example">
inversa1 [] ++ ys
= [] ++ ys              [por inversa1.1]
= ys                    [por ++.1]
= inversa2Aux [] ys     [por inversa2Aux.1]
</pre></li>
</ul></li>

<li><p>
Caso inductivo <code>xs=(a:as)</code>: La hipótesis de inducción es
</p>
<pre class="example">
(∀ ys :: [a]) inversa1 as ++ ys = inversa2Aux as ys
</pre>

<p>
Hay que demostrar que
</p>
<pre class="example">
(∀ ys :: [a]) inversa1 (a:as) ++ ys = inversa2Aux (a:as) ys
</pre>

<p>
Demostración
</p>
<pre class="example">
inversa1 (a:as) ++ ys
= (inversa1 as ++ [a]) ++ ys    [por inversa1.2]
= (inversa1 as) ++ ([a] ++ ys)  [por asociativa de ++]
= (inversa1 as) ++ (a:ys)       [por ley unitaria]
= (inversa2Aux as (a:ys)        [por hip. de inducción]
= inversa2Aux (a:as) ys         [por inversa2Aux.2]
</pre></li>
</ul>
</div>
</div>

<div id="outline-container-org831c863" class="outline-2">
<h2 id="org831c863"><span class="section-number-2">5</span> Propiedades de funciones de orden superior</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org68887ae" class="outline-3">
<h3 id="org68887ae"><span class="section-number-3">5.1</span> Relación entre <code>sum</code> y <code>map</code></h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li><p>
Definición de la función <code>sum</code>:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">sum</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Int</span><span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Int</span>
<span style="color: #0000ff;">sum</span> <span style="color: #707183;">[]</span>     <span style="color: #a0522d;">=</span> 0
<span style="color: #0000ff;">sum</span> <span style="color: #707183;">(</span>x<span style="color: #228b22;">:</span>xs<span style="color: #707183;">)</span> <span style="color: #a0522d;">=</span> x <span style="color: #a0522d;">+</span> sum xs
</pre>
</div></li>

<li>Propiedad: <code>sum (map (2*) xs) = 2 * sum xs</code></li>

<li><p>
Propiedad con QuickCheck:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">prop_sum_map</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">[</span><span style="color: #228b22;">Int</span><span style="color: #707183;">]</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Bool</span>
<span style="color: #0000ff;">prop_sum_map</span> xs <span style="color: #a0522d;">=</span> sum <span style="color: #707183;">(</span>map <span style="color: #7388d6;">(</span>2<span style="color: #a0522d;">*</span><span style="color: #7388d6;">)</span> xs<span style="color: #707183;">)</span> <span style="color: #a0522d;">==</span> 2 <span style="color: #a0522d;">*</span> sum xs
</pre>
</div></li>

<li><p>
Comprobación:
</p>
<pre class="example">
λ&gt; quickCheck prop_sum_map
+++ OK, passed 100 tests.
</pre></li>

<li>Demostración de la propiedad por inducción en <code>xs</code>
<ul class="org-ul">
<li><p>
Caso <code>[]</code>:
</p>
<pre class="example">
sum (map (2*) xs)
= sum (map (2*) [])  [por hipótesis]
= sum []             [por map.1]
= 0                  [por sum.1]
= 2 * 0              [por aritmética]
= 2 * sum []         [por sum.1]
= 2 * sum xs         [por hipótesis]
</pre></li>
</ul></li>

<li><p>
Caso <code>xs = y:ys</code>:
</p>
<pre class="example">
sum (map (2*) xs)
= sum (map (2*) (y:ys))         [por hipótesis]
= sum ((2*) y : (map (2*) ys))  [por map.2]
= (2*) y + (sum (map (2*) ys))  [por sum.2]
= (2*) y + (2 * sum ys)         [por hip. de inducción]
= (2 * y) + (2 * sum ys)        [por (2*)]
= 2 * (y + sum ys)              [por aritmética]
= 2 * sum (y:ys)                [por sum.2]
= 2 * sum xs                    [por hipótesis]
</pre></li>
</ul>
</div>
</div>

<div id="outline-container-orga8db848" class="outline-3">
<h3 id="orga8db848"><span class="section-number-3">5.2</span> Comprobación de propiedades con argumentos funcionales</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li><p>
La aplicación de una función a los elementos de una lista conserva su
longitud:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #0000ff;">prop_map_length</span> <span style="color: #707183;">(</span><span style="color: #228b22;">Fun</span> <span style="color: #a020f0;">_</span> f<span style="color: #707183;">)</span> xs <span style="color: #a0522d;">=</span>
  length <span style="color: #707183;">(</span>map f xs<span style="color: #707183;">)</span> <span style="color: #a0522d;">==</span> length xs
</pre>
</div></li>

<li><p>
En el inicio del fichero hay que escribir
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">import</span> <span style="color: #228b22;">Test.QuickCheck.Function</span>
</pre>
</div></li>

<li><p>
Comprobación
</p>
<pre class="example">
λ&gt; quickCheck prop_map_length
+++ OK, passed 100 tests.
</pre></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org835b3dd" class="outline-2">
<h2 id="org835b3dd"><span class="section-number-2">6</span> Bibliografía</h2>
<div class="outline-text-2" id="text-6">
<ul class="org-ul">
<li>H.C. Cunningham. <b>Notes on Functional Programming with Haskell</b>.</li>

<li>J. Fokker. <b>Programación funcional</b>.</li>

<li>G. Hutton. <b>Programming in Haskell</b>. Cambridge University Press, 2007.
<ul class="org-ul">
<li>Cap. 13: Reasoning about programs.</li>
</ul></li>

<li>B.C. Ruiz, F. Gutiérrez, P. Guerrero y J.E. Gallardo. <b>Razonando con
Haskell</b>. Thompson, 2004.
<ul class="org-ul">
<li>Cap. 6: Programación con listas.</li>
</ul></li>

<li>S. Thompson. <b>Haskell: The Craft of Functional Programming</b>, Second
Edition. Addison-Wesley, 1999.
<ul class="org-ul">
<li>Cap. 8: Reasoning about programs.</li>
</ul></li>

<li>E.P. Wentworth. <b>Introduction to funcional programming</b>.</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<hr>
<center>
<p><a href="/cursos/i1m/">Inicial</a> |
   <a href="/cursos/i1m/temas.html">Temas  </a>
</p>
</center>
<div id="extras">
  <p><a href="/">José A. Alonso Jiménez</a>
  <p>Sevilla, 25 de abril del 2021</p>
  <p>Licencia <a href="https://creativecommons.org/licenses/by-nc-sa/2.5/es/">
  Creative Commons Reconocimiento-NoComercial-CompartirIgual</a>.</p>
</div>
</div>
</body>
</html>
